---
title: "TCP套接字选项"
date: 2023-12-26T16:38:43+08:00
draft: true
---

getsockopt和setsockopt函数的第二个参数, 为IPPROTO_TCP。

## TCP_MAXSEG 套接字选项
本选项允许我们获取或设置TCP连接的最大分节大小(MSS)。返回值是我们的TCP可以发送给对端的最大数据量，
它通常是由对端使用SYN分节通告的MSS，除非我们的TCP选择使用一个比对端通告的MSS小些的值。如果该值
在相应套接字的连接建立之前取得，那么返回值是未从对端收到MSS选项的情况下所用的默认值。还得注意的是，
如果用上譬如说时间戳选项的话，那么实际用于连接中的最大分节大小可能小于本套接字选项的返回值，因为时
间戳选项在每个分节中要占用12字节的TCP选项容量。

如果TCP支持路径MTU发现功能，那么它将发送的每个分节的最大数据量还可能在连接存活期内改变。如果到对端
的路径发生变动，该值就会有所调整。

本套接字选项也可以由应用进程设置。这一点并非在所有系统上都可行，毕竟本选项原本是个只读选项。4.4BSD
限制应用进程只能减少其值，而不能增加其值。既然本选项控制TCP可以发送的每个分节的数据量，禁止应用进程
增加其值是明智的。一旦连接建立，本选项的值就是对端通告的MSS选项值，TCP不能发送超过该值的分节。当然，
TCP总是可以发送数据量少于对端通告的MSS值的分节。

## TCP_NODELAY
开启本选项将禁止TCP的Nagle算法。默认情况下该算法是启动的。Nagle算法的目的在于减少广城网(WAN)上小
分组的数目。该算法指出:如果某个给定连接上有待确认数据(outstanding data)，那么原本应该作为用户写
操作之响应的在该连接上立即发送相应小分组的行为就不会发生，直到现有数据被确认为止。“这里“小”分组的定义
就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组，Nagle算法的目的在于防止一个连接在任何时刻有
多个小分组待确认。

（解释这段话下面意思
如果某个给定连接上有待确认数据(outstanding data)，那么原本应该作为用户写
操作之响应的在该连接上立即发送相应小分组的行为就不会发生，直到现有数据被确认为止。

如果tcp链接上面有待确认的数据，就是已经发送了数据，没有收到接收方收到了数据的确认，那么在有未确认的
数据时，tcp协议不会立即发送新的小数据包作为对用户写操作的想用，这通常是为效率和网络拥塞控制。nagle
会延迟发送小的数据包，知道之前发送的数据被确认，或者积累了足够大的数据包位置。这是为了减少网络上的小
分组数量，提高网络效率。）

Rlogin和Telnet的客户端是两个常见的小分组产生进程，它们通常把每次击键作为单个分组发送。在快速的局域网
(LAN)上，我们通常不会注意到Nagle算法对这些客户进程的影啊，因为小分组所需的确认时间一般也就几毫秒，远
远小于我们相继键入两个字符的间隔时间。然市在广域网上，小分组所需的确认时间可能长达一秒，我们就会注意到
字符回显的延迟，而且该延迟往往被Nagle算法进一步放大。

考虑下面的例子:我们在Rlogin或Telnet的客户端键入6个字符的串“hello!”，每个字符间间隔正好是250ms。到
服务器端的RTT为600ms，而且服务器立即发回每个字符的回显。我们假设对客户端字符的ACK是和字符回显一同发回
给客户端的，并且忽略容户端发送的对服务器端回显的ACK。假设Nagle算法是禁止的，我们得到图7-14所示的12个
分组。

图中每个字符在各自的分组中发送:数据分节从左到右，ACK从右到左。

如果Nagle算法是开启的(这是默认情形)，我们就得到图7-15所示的8个分组。第一个字符独自作为一个分组发送，然
而下两个字符没有立即发送，因为该连接上有一个小分组待确认。在时刻600处收到对第一个分组的ACK后(该ACK由第
一个字符的回显捎带)，这两个字符才被发送。在该分组在时刻1200处被确认之前，没有其他小分组被发送。

Nagle算法常常与另一个TCP算法联合使用:ACK延滞算法(delayed ACK algorithm)。该算法使得TCP在接收到数据
后不立即发送ACK，而是等待一小段时间(典型值为50~200ms)，然后才发送ACK。TCP期待在这一小段时间内自身有数据
发送回对端，被延滞的ACK就可以由这些数据捎带，从而省掉一个TCP分节。这种情形对于Rlogin和Telnet客户来说通常
可行，因为它们的服务器一般都回显客户发送来的每个字符，这样对容户端字符的ACK完全可以在服务器对该字符的回显中
捎带返回。

![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_14_15.jpg)

然而对于其服务器不在相反方向产生数据以便携带ACK的客户来说，ACK延滞算法存在问题。这些客户可能觉察到明显的延迟，
因为客户TCP要等到服务器的ACK延滞定时器超时才继续给服务器发送数据。这些客户需要一种禁止Nagle算法的方法，
TCP_NODELAY选项就能起到这个作用。

另一类不适合使用Nagle算法和TCP的ACK延滞算法的客户是以若干小片数据向服务器发送单个逻辑请求的客户。举例来说，
假设某个客户向它的服务器发送一个400字节的请求，该请求由一个4字节的请求类型和后跟的396字节的请求数据构成。
如果客户先执行一个4字节的write调用，再执行一个396字节的write调用，那么第二个写操作的数据将一直等到服务器的
TCP确认了第一个写操作的4字节数据后才由客户的TCP发送出去。而且，由于服务器应用进程难以在收到其余396字节前对
先收到的4字节数据进行操作，服务器的TCP將拖延该4字节数据的ACK(也就是说，哲时不会有从服务器到容户的任何数据
可以捎带这个ACK)。有三种办法修正这类客户程序。

(1)使用writev而不是两次调用write。对于本例子，单个writev调用最终导致调用TCP输出功能一次而不是两次，其结果
是只产生一个TCP分节。这是首选的办法。

(2)把前4字节的数据和后396字节的数据复制到单个缓冲区中，然后对该缓冲区调用一次write.

(3)设置TCP_NODELAY套接字选项，继续调用write两次。这是最不可取的办法，而且有损于网络，通常不应该考虑。


