---
title: "通用套接字选项"
date: 2023-12-25T18:43:23+08:00
draft: true
---

## SO_BROADCAST套接字选项
(broadcast)

本选项开启或禁止进程发送广播消息的能力。只有数据报套接字支持广播，并且还必须是在支持广播消息的网络上(例如以太网、令牌环网等)。
我们不可能在点对点链路上进行广播，也不可能在基于连接的传输协议(例如TCP和SCTP)之上进行广播。

由于应用进程在发送广播数据报之前必须设置本套接字选项，因此它能够有效地防止一个进程在其应用程序根本没有设计成可广播时就发送广播
数据报。举例来说，一个UDP应用程序可能以命令行参数的形式取得目的IP地址，不过它并不期望用户键入一个广播地址。处理方法并非让应用
进程来确定一个给定地址是否为广播地址，而是在内核中进行测试:如果该目的地址是一个广播地址且本套接字选项没有设置，那么返回
EACCES错误。

## SO_DEBUG套接字选项
(debug)

本选项仅由TCP支持。当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和接收的所有分组保留详细跟踪信息。这些信息保存在内核
的某个环形缓冲区中，并可使用trpt程序进行检查。

## SO_DONTROUTE
(don't route)

本选项规定外出的分组将绕过底层协议的正常路由机制。举例来说，在IPV4情况下外出分组将被定向到适当的本地接口，也就是由其目的地址的
网络和子网部分确定的本地接口。如果这样的本地接口无法由目的地址确定(臂如说目的地主机不在一个点对点链路的另一端，也不在一个共享的
网络上)，那么返回ENETUNREACH错误。

给函数send、sendto或sendmsg使用MSG_DONTROUTE标志也能在个别的数据报上取得与本选项相同的效果。

路由守护进程(routed和gated)经常使用本选项来绕过路由表(路由表不正确的情况下)，以强制將分组从特定接口送出。

## SO_ERROR 套接字选项
当一个套接字上发生错误时，源自Berkcley的内核中的协议模块将该套接宇的名为so_error的变量设为标准的Unix Exxx值中的一个，
我们称它为该套接字的待处理错误(pending error)。内核能够以下面两种方式之一立即通知进程这个错误。
(1)如果进程阻塞在对该套接字的select调用上，那么无论是检查可读条件还是可写条件，select均返回并设置其中一个或所有两个条件。
(2)如果进程使用信号驱动式I/O模型，那就给进程或进程组产生一个SIGIO信号。

进程然后可以通过访问SO_ERROR套接字选项获取so_error的值。由getsockopt返回的整数值就是该套接字的待处理错误。
so_error随后由内核复位为0。

当进程调用read且没有数据返回时，如果so_error为非0值，那么read返回-1且errno被置为so_error的值。so_error随后被复位为0。
如果该套接字上有数据在排队等待读取，那么read返回那此数据而不是返回错误条件。如果在进程调用write时so_error为非0值，那么
write返回-1且errno被设为so_error的值。so_error随后被复位为0。

## SO_KEEPALIVE 套接字选项
(keep alive)

给一个TCP套接字设置保持存活(keep-alive)选项后，如果2小时内在该套接字的任一方向上都没有数据交换，TCP就自动给对端发送一个
保持存活探测分节(keep-alive probe)。这是一个对端必须响应的TCP分节，它会导致以下三种情况之一。

(1)对端以期望的ACK响应。应用进程得不到通知(因为一切正常)。在又经过仍无动静的2小时后，TCP将发出另一个探测分节。

(2)对端以RST响应，它告知本端TCP:对瑞已崩溃且己重新启动。该套接字的待处理错误被置为ECONNRESET，套接字本身则被关闭。

(3)对端对保持存活探测分节没有任何响应。源自Berkeley的TCP将另外发送8个探测分节，两两相隔75秒，试图得到一个响应。
TCP在发出第一个探测分节后11分15秒内若没有得到任何啊应则放弃。

如果根本没有对TCP的探测分节的响应，该套接字的待处理错误就被置为ETIMEOUT，套接字本身则被关闭。然而如果该套接字收到一个
ICMP错误作为某个探测分节的响应，那就返回相应的错误，套接字本身也被关闭。这种情形下一个常见的ICMP错误是“host unreachable”
〈主机不可达)，说明对端主机可能并没有崩溃，只是不可达，这种情况下待处理错误被置为EHOSTUNREACH。发生这种情况的原因或者是发
生网络故障，或者是对端主机己经崩溃，而最后一跳的路由器也己经检测到它的崩溃。

对于本选项的一个最常见的问题无疑是时间参数是否可改(通常是想把2小时的无活动周期改为短些的值)。大多数内核是基于整个内核维护这些
时间参数的，而不是基于每个套接字维护的，因此如果把无活动周期从2小时改为(臂如说)15分钟，那将影响到该主机上所有开启了本选项的套
接字。然而这些问题通常是由对本选项功用的误解导致的。

本选项的功用是检测对端主机是否崩溃或变得不可达(臂如拨号调制解调器连接掉线，电源发生故障，等等)。如果对端进程崩溃，它的TCP将跨
连接发送一个FIN，这可以通过调用select很容易地检测到。同时也要认识到，即使对任何保持存活探测分节均无响应(第三种情况)，我们也
不能肯定对端主机已经崩溃，因而TCP可能会终止一个有效连接。某个中间路由器崩溃15分钟是有可能的，而这段时间正好与主机的11分15秒的
保持存活探测周期完全重迭。事实上本功能称为“切断”(make-dead)而不是“保持存活〞也许更合适些，因为它可能终止存活的连接。

本选项一般由服务器使用，不过客户也可以使用。服务器使用本选项是因为它们花大部分时间阻塞在等待穿越TCP连接的输入上，也就是说在等
待客户的请求。然而如果容户主机连接掉线、电源掉电或系统崩溃，服务器进程将永远不会知道，并将继续等待永远不会到达的输入。我们称这
种情况为半开连接(half-open connection)。保持存活选项将检测出这些半开连接并终止它们。

有些服务器(特別是FTP服务器)提供一个分钟量级的应用层超时。这足由应用进程本身完成的，一般在读下一个客户命令的read调用附近。这个
超时与本套接字选项无关。这通常是清理通向不可达客户的半开连接的较好办法，因为如果应用系统自己实现超时，应用进程就具备完全的控制能力。

## SO_LINGER 套接字选项
so_linger

本选项指定close函数对面向连接的协议(例如TCP和SCTP，但不是UDP)如何操作。默认操作是close立即返回，但是如果有数据残留在套接字
发送缓冲区中，系统将试着把这些数据发送给对端。

![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/check_optioal_method.jpg)

SO_LINGER套接字选项使得我们可以改变这个默认设置。本选项要求在用户进程与内核间传递如下结构，它在头文件<sys/socket.h>中定义:
```c
struct linger 
{
    int l_onoff;    // 0 = off, nonzero = on;
    int l_linger;   // linger time, POSIX specifies units as seconds
};
```
对setsockopt的调用将根据其中两个结构成员的值形成下列3种情形之一。

(1)如果l_onoff为0，那么关闭本选项。l_linger的值被忽略，先前讨论的TCP默认设置生效，即close立即返回。

(2)如果l_onoff为非0值且l_linger为0，那么当close某个连接时TCP将中止该连接。这就是说TCP将丢弃保留在套
接字发送缓冲区中的任何数据，并发送一个RST给对端，而没有通常的四分组连接终止序列。这么一来避免了TCP的TIME_WAIT
状态，然而存在以下可能性:在2MSL秒内创建该连接的另一个化身，导致来自刚被终止的连接上的旧的重复分节被不正确地递送
到新的化身上。
这种情形下SCTP也通过发送一个ABORT块给对端而中止性地关闭关联。

(3)如果l_onoff为非0值且l_linger也为非0值，那么当套接字关闭时内核将拖廷一段时间。这就是说如果在套接字发送缓冲区
中仍残留有数据，那么进程将被投入睡眠，直到(a)所有数据都已发送完且均被对方确认或(b)延滞时间到。如果套接字被设置为
非阻塞型，那么它将不等待close完成，即使延滞时间为非0也是如此。当使用SO_LINGER选项的这个特性时，应用进程检查close
的返回值是非常重要的，因为如果在数据发送完并被确认前延滞时间到的话，close将返回ENOULDBLOCK错误，且套接字发送缓冲
区中的任何残留数据都被丢弃。

现在我们需要看看，对于己讨论的各种情况，套接字上的close确切来说是什么时候返回的。我们假设客户将数据写到
套接字上，然后调用close。图7-7给出了默认情况。

![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_7_close_default.jpg)
我们假设在客户数据到达时，服务器暂时处于忙状态。那么这些数据由TCP加入到服务器的套接字接收缓冲区中。类似地，
下一个分节即客户的FIN也加入该套接字接收缓冲区中(不论实现以何种方法记录该连接上已收到一个FIN这一事件)。默
认情况下客户的close立即返回。如图所示，客户的close可能在服务器读套接字接收缓区中的剩余数据之前就返回。对
于服务器主机来说，在服务器应用进程读这些剩余数据之前就崩溃是完全可能的，而且客户应用进程永远不会知道。

客户可以设置SO_LINGER套接字选项，指定一个正的延滞时间。这种情况下客户的close要到它的数据和FIN己被服务器主机
的TCP确认后才返回，如图7-8所示。
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_8_close.jpg)
然而我们仍然有与图7-7一样的问题:在服务器应用进程读剩余数据之前，服务器主机可能崩溃，并且客户应用进程永远不会知道。
更糟糕的是，图7-9展示了当给SO_LINGER选项设置偏低的延滞时间值时可能发生的现象。
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_9_close.jpg)
这里有一个基本原则:设置SO_LINGER套接字选项后，close的成功返回只是告诉我们先前发送的数据(和FIN)己由对端TCP
确认，而不能告诉我们对端应用进程是否己读取数据。如果不设置该套接字选项，那么我们连对端TCP是否确认了数据都不知道。

让客户知道服务器已读取其数据的一个方法是改为调用shutdown(并设置它的第二个參数为SHUT_WR)而不是调用close，并等待
对端close连接的当地端(服务器端)，如图7-10所示
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_10_close.jpg)
比较本图与图7-7及图7-8我们看到，当关闭连接的本地端(客户端)时，根据所调用的函数(close或shutdown)以及是否设置了
SO_LINGER套接字选项，可在以下3个不同的时机返回。

(1)close立即返回，根本不等待(默认状况，图7-7)。

(2)close一直拖延到接收了对于客户端FIN的ACK才返回(图7-8)。

(3)后跟一个read调用的shutdown一直等到接收了对端的FIN才返回(图7-10)。

获知对端应用进程已读取我们的数据的另外一个方法是使用应用级确认(application-level acknowledge，简称应用ACK(application ACK))。
在下面的例子中，客户在向服务器发送数据后调用read来读取1个字节的数据:
```c
char ack;
Write(sockfd, data, nbytes);    // data from client to server
n = Read(sockfd, &ack, 1);      // wait for application-level ACK
```
服务器读取来自客户的数据后发回1个字节的应用级ACK
```c
nbytes = Read(sockfd, buff, sizeof(buff));  // data from client
// server verifies it reveived correct amount of data from the client
Write(sockfd, "", 1);   // server's ack back to client
```
当客户的read返回时，我们可以保证服务器进程已读完了我们所发送的所有数据。(假设服务器知道客户要发送多少数据，或者由应用程序定义了某个记录
结束标志，不过这儿没有给出。)本例子的应用级ACK是值为0的1个字节，不过该字节的内容可以用来从服务器向客户指示其他的条件。图7-11展示了可能
的分组交换过程。
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_11_close.jpg)

图7-12汇总了对shutdown的两种可能调用和对close的三种可能调用，以及它们对TCP套接字的影响。
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_12.jpg)

## SO_OOBINLINE 套接字选项
(so_oobinline)

当本选项开启时，带外数据将被留在正常的输入队列中(即在线留存)。这种情况下接收函数的MSG_OOB标志不能用来读带外数据。

## SO_RCVBUF 和 SO_SNDBUF 套接字选项
每个套接字都有一个发送缓冲区和一个接收缓冲区。

接收缓冲区被TCP、UDP和SCTP用来保存接收到的数据，直到由应用进程来读取。对于TCP来说，套接字接收缓冲区中可用空间
的大小限定了TCP通告对端的窗口大小。TCP套接字接收缓冲区不可能溢出，因为不允许对端发出超过本端所通告窗又大小的数
据。这就是TCP的流量控制，如果对端无视端口大小而发出了超过该窗口大小的数据，本端TCP将丢弃它们。然而对于UDP来说，
当接收到的数据报装不进套接字接收缓冲区时，该数据报就被丢弃。回顾一下，UDP是没有流量控制的:较快的发送端可以很容易
地淹没较慢的接收端，导致接收端的UDP丢弃数据报，事实上较快的发送端甚至可以淹没本机的网络接口，导致数据报被本机丢弃。

这两个套接字选项允许我们改变这两个缓冲区的默认大小。对于不同的实现，默认值的大小可以有很大的差别。较早期的源自
Berkeley的实现将TCP发送和接收缓冲区的大小均默认为4096字节，而较新的系统使用较大的值，可以是8192~61440字节间的
任何值。如果主机支持NFS，那么UDP发送缓冲区的大小经常默认为9000字节左右的一个值，而UDP接收缓冲区的大小则经常默认
为40000字节左右的一个值。

当设置TCP套接字接收缓冲区的大小时，函数调用的顺序很重要。这是因为TCP的窗口规模选项是在建立连接时用SYN分节与对端
互换得到的。对于客户，这意味着SO_RCVBUF选项必须在调用connect之前设置；对于服务器，这意味着该选项必须在调用listen
之前给监听套接字设置。给己连接套接字设置该选项对于可能存在的窗口规模选项没有任何影响，因为accept直到TCP的三路握手
完成才会创建并返回己连接套接字。这就是必须给监听套接字设置本选项的原因。(套接字缓冲区的大小总是由新创建的己连接套接
字从监听套接字维承布来）

TCP套接字缓冲区的大小至少应该是相应连接的MSS值的四倍。对于单向数据传输(臂如单个方向的文件传送)，当我们说“套接字缓
冲区大小”时，我们指的是发送端主机上的套接字发送缓冲区大小和接收端主机上的套接字接收缓冲区大小。对于双向数据传输，我
们在发送端指的是收发两个套接字缓冲区的大小，在接收端也是指收发两个套接字缓冲区的大小。典型的缓冲区大小默认值是8192
字节或更大，典型的MSS值为512或1460，这些要求一般总能被满足。

TCP套接字缓冲区的大小至少为MSS值的4倍这一点的依据是TCP快速恢复算法的工作机制。TCP发送端使用3个重复的确认来检测某个
分节是否丢失。发现某个分节丢失后，接收端將给新收到的每个分节发送一个重复的确认。如果窗口大小不足以存放4个这样的分节，
那就不可能连发三个重复的确认，从而无法激活快速恢复算法。

为避免潜在的缓冲区空间浪费，TCP套接字缓冲区大小还必须是相应连接的MSS值的偶数倍。有些实现替应用进程处理这个细节问题，
在连接建立后向上舍入套接字缓冲区大小。这是在建立连接之前设置这两个套接字选项的另外一个原因。使用默认的4.4BSD大小
8192举例来说，假设以太网的MSS为1460，在连接建立时收发两个套接字缓冲区的大小将被向上舍入成8760(6×1460)。这个要求
并非必需；只不过套接字缓冲区中MSS整数倍大小以外的空间不会被使用。

在设置套接字缓冲区大小时另一个需考虑的问题涉及性能。图7-13展示了两个端点之间容量为8个分节的一个TCP连接(我们称其为管道)
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/7_13.jpg)
我们在顶部给出4个数据分节，在底部给出4个ACK。即使管道中只有4个数据分节，客户也必须有至少8个分节容量的发送级冲区，因为客户
TCP必须为每个分节保留一个副本，直到接收到来自服务器的相应ACK。

这里我们忽略了一些细节。首先，TCP的慢启动算法限制了在一个空闲连接上最初发送分节的速度。共次，TCP通常每两个分节确认一次，
而不是我们所示的每个分节确认一次。

理解的重点在于全双工管道的概念、它的容最以及它们如何关系到连接两端的套接字缓冲区大小。管道的容量称为带宽一延迟积(bandwidth-delay product)，
它通过将带宽(bit/s)和RTT(秒)相乘，再将结果由位转换为字节计算得到。其中RTT可以很容易地使用ping程序测得。

带宽是相应于两个端点之间最慢链路的值，某种程度上是己知的。举例来说，RTT为60ms的一条T1链路(1 536 000 bit/s)的带宽-延迟积为11 520字节。如果
套接字缓冲区大小小于该值，管道将不会处于满状态，性能也将低于期望值。当带宽变大(如45Mbit/s的T3链路)或RTT变大(如RTT约为500ms的卫星链路〉时，
套接字缓冲区也需要增长。当带宽-延迟积超过TCP的最大正常窗口大小(65535字节)时，两端就得设置我们在提到过的TCP长胖管道(long fat pipe)选项。

大多数实現对套接字发送级冲区和接收缓冲区的大小都设有一个上限，有时这个上限可由管理员进行修政。较早期的源自Berkeley的实现有一个约为52000字节的
硬上限，然而较新的实现特默认值增加为256000宇节甚至更大，而且通第可以由管理员继续增加。不幸的是，对于应用程序来说，没有一个简单的方法來确定这个
极限。POSIX定义了fpathconf函數(大多數实現都支持)。使用_PC_SOCK_MAXBUE常值作为它的第二个参数，我们就能获取套接字缓冲区的最大大小.当然应用
程序也可以先尝试把套接字缓冲区设置成预想的大小，若失败則减半继续尝试，直到成功。最后我们指出，应用程序在把套接字缓冲区的大小设置成某个预配置的
“大”值时，应该确保这样做不会反而让缓冲区变小了;最好一开始就调用getsockopt获取系統的默认值并判定是否已足够大。

## SO_RCVLOWAT 和 SO_SNDLOWAT 套接字选项
每个套接字还有一个接收低水位标记和一个发送低水位标记。它们由select函数使用。这两个套接字选项允许我们修改这两个低水位标记。
接收低水位标记是让select返回“可读”时套接字接收缓冲区中所需的数据量。对于TCP、UDP和SCTP套接字，其默认值为1。发送低水位
标记是让select返回“可写”时套接字发送缓冲区中所需的可用空间。对于TCP套接字，其默认值通常为2048。UDP也使用发送低水位标记，
然而由于UDP套接字的发送缓冲区中可用空间的字节数从不改变(因为UDP并不为由应用进程传递给它的数据报保留副本)，只要一个UDP套接
字的发送缓冲区大小大于该套接字的低水位标记，该UDP套接字就总是可写。UDP并没有发送缓冲区，而只有发送缓冲区大小这个属性。

## SO_RCVTIMEO 和 SO_SNDTIMEO 套接字选项
这两个选项允许我们给套接字的接收和发送设置一个超时值。注意，访问它们的getsockopt和setsockopt函数的参数是指向timeval结构
的指针，与select所用參数相同。这可让我们用秒数和微秒数来规定超时。我们通过设置其值为0s和Ous来禁止超时。默认情况下这两个超时
都是禁止的。

接收超时影响5个输入函数:read、readv、recv、recvfrom和recvmsg。发送超时影响5个输出函数:write、writev、send、sendto
和sendmsg。

## SO_REUSEADDR 和 SO_REUSEPORT 套接字选项
SO_REUSEADDR套接字选项能起到以下4个不同的功用。

(1)SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将该端口用作它们的本地端口的连接仍存在。
这个条件通常是这样碰到的:
a 启动一个监听服务器;
b 连接请求到达，派生一个子进程来处理这个客户:
c 监听服务器终止，但子进程继续为现有连接上的客户提供服务;
d 重启监听服务器。

默认情况下，当监听服务器在步骤d通过调用socket、bind和listen重新启动时，由于它试图绑定一个现有连接(即正由早先派生的那个子进程处理者
的连接)上的端口，从而bind调用会失败。但是如果该服务器在socket和bind两个调用之间设置了SO_REUSEADDR套接字选项，那么bind将成功。
所有TCP服务器都应该指定本套接字选项，以允许服务器在这种情形下被重新启动。

这种情形是USENET中问得最频繁的问题之一。

(2)SO_REUSEADDR 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。这对于使用IP别名技术托管多个
HTTP服务器的网点(site)来说是很常见的。举例来说，假设本地主机的主IP地址为198.69.10.2，不过它有两个别名:198.69.10.128和
198.69.10.129。在其上启动三个HTTP服务器。第一个HTTP服务器以本地通配IP地址INADDR_ANY和本地端口号80(HTTP的众所周知端口)调用bind。
第二个HTTP服务器以本地IP地址198.69.10.128和本地端口号80调用bind。这次调用bind将失败，除非在调用前设置了SO_REUSEADDR套接字选项。
第三个HTTP服务器以本地IP地址198.69.10.129和本地端口号80调用bind。这次调用bind成功的先决条件同样是预先设置SO_REUSEADR。
假设SO_REUSEADDR均己设置，从而三个服务器都启动了，目的IP地址为198.69.10.128、目的端口号为80的外来TCP连接请求将被递送给第二个服务器，
目的IP地址为198.69.10.129、目的端口号为80的外来诮求将被递送给第三个服务器，目的端口号为80的所有其他TCP连接请求将都递送给第一个服务器。
这个“默认〞服务器处理目的地址为198.69.10.2或该主机己配置的任何其他IP别名的请求。这里通配地址的意思就是“没有更好的(即更为明确的)匹配的
任何地址”。注意，允许某个给定服务存在多个服务器的情形在服务器总是设置SO_REUSEADDR套接字选项时是自动处理的(我们建议设置这个选项)。

对于TCP，我们绝不可能启动捆绑相同IP地址和相同端口号的多个服务器:这是完全重复的捆绑(completely duplicate binding)。也就是说，我们
不可能在启动绑定198.69.10.2和端口80的服务器后，再启动同样捆绑198.69.10.2和端口80的另一个服务器，即使我们给第二个服务器设置了
SO_REUSEADDR套接字选项也不管用。

为了安全起见，有此操作系统不允许对已经绑定了通配地址的端口再绑定任何“更为明确的”地址，也就是说不论是否预先设置SO_REUSEADDR，上述例子中
的系列bind调用都会失败。在这样的系統上，执行通配地址捆綁的服务器进程必须最后一个启动。这么做是为了防止把恶意的服务器捆绑到某个系统服务正
在使用的IP地址和端口上，造成合法请求被截取。这一点对于NFS更成问题，因为NFS通常不使用特权端口。

(3)SO_REUSEADDR允许单个进程捆绑同一端口到多个套接字上，只要每次捆绑指定不同的本地IP地址即可。在不支持IP_RECVDSTADDR 套接字选项的
系统上，这对于要求知道客户请求的目的IP地址的UDP服务器来说是非常普遍的。TCP服务器通常不使用这种方法，因为TCP服务器在建立连接后总是能够
通过调用getsockname来确定客户请求的目的IP地址。然而对于希望在一个多目的主机的若干个(而非全部)本地地址上服务连接的TCP服务器进程来说，
仍需采用这种方法。

(4)SO_REUSEADDR 允许完全重复的捆绑:当一个IP地址和端口己绑定到某个套接字上时，如果传输协议支持，同样的IP地址和端口还可以捆绑到另一个
套接字上。一般来说本特性仅支持UDP套接字。

本特性用于多播时，允许在同一个主机上同时运行同一个应用程序的多个副本。当一个UDP数据报需由这些重复捆鄉套接字中的一个接收时，所用规则为:
如果该数据报的目的地址是一个广播地址或多播地址，那就给每个匹配的套接字递送一个该数据报的副本:但是如果该数据报的目的地址是一个单播地址，
那么它只递送给单个套接字。在单播数据报情况下，如果有多个套接字匹配该数据报，那么该选择由哪个套接字按收它取决于实现。


4.4BSD随多播支特的添加引入了 SO_REUSEPORT 这个套接字选项。它并末在SO_REUSEADDR上重载所需多播语义(即允许完全重复的捆绑)，而是给
SO_REUSEPORT引入了以下语义:

(1)本选项允许完全重复的捆绋，不过只有在想要捆绑同—IP地址和端口的每个套接字都指定了本套接字选项才行;

(2）如果被捆绑的IP地址是一个多播地址，那么SO_REUSEADDR和SO_REUSEPORT被认为是等效的。本套接字选项的问题在于并非所有系统都支持它。
在那些不文持本选项但足文持多播的系统上，我们改用SO_REUSEADDR以允许合理的完全重复的捆绑(也就是同一时刻在同一个主机上可运行多次且期
待接收广播或多播数据报的UDP服务器)。


我们以下面的建议来总结对这些套接字选项的讨论:

(1) 在所有TCP服务器程序中，在调用bind之前设置SO_REUSEADDR套接字选项:

(2)当编写一个可在同一时刻在同一主机上运行多次的多播应用程序时，设置SO_REUSEADDR套接字选项，并将所参加多播组的地址作为本地IP地址绑定。

SO_REUSEADDR有一个潜在的安全问题。举例来说，假设存在一个绑定了通配地址和端口5555的套接字，如果指定SO_REUSEADDR，我们就可以把相同的
端口捆绑到不同的IP地址上，臂如说就是所在主机的主IP地址。此后目的地为端口5555及新绑定IP地址的数据报将被递送到新的套接字，而不是递送到
绑定了通配地址的己有套接字。这些数据报可以是TCP的SYN分节、SCTP的INIT块或UDP数据报。对于大多数众所周知的服务如HTTP、FTP和Telnet来说，
这不成问题，因为这些服务器绑定的是保留端口。这种情况下，后来的试图捆绑这些端口更为明确的实例(也就是盗用这些端口)的任何进程都需要超级用户
特权。然而NFS可能是一个问题，因为它的通常端口(2049)并不是保留端口。

## SO_TYPE 套接字选项
本选项返回套接字的类型，返回的整数值是一个诸如SOCK_STREAM或SO_DGRAM之类的值。本选项通常由启动时继承了套接字的进程使用。

## SO_USELOOPBACK
本选项仅用于路由域(AF_ROUTE)的套接字。对于这些套接字，它的默认设置为打开(这是唯一一个默认值为打开而不是关闭的SO_xx二元套接字选项)。
当本选项开启时，相应套接字将接收在其上发送的任何数据报的一个副本。












