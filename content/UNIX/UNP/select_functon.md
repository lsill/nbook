---
title: "select函数"
date: 2023-12-22T16:39:12+08:00
draft: true
---

# select 函数
该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。

作为一个例子，我们可以调用select，告知内核仅在下列情况发生时才返回:
- 集合{1，4，5}中的任何描述符准各好读;
- 集合{2，7}中的任何描述符准各好写:
- 集合{1，4;中的任何描述符有异常系件待处理:
- 己经历了10.2秒。

也就是说，我们调用select告知内核对哪些描述符(就读、写或异常条件)感兴趣以及等待多长时间。我们感兴趣的描述符不局限于
套接字，任何描述符都可以使用select来测试。

```c
#include <sys/select.h>
#include <sys/time.h>
int select (int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout) ;
// 返回:若有就绪描述符则为其数目，若超时则为0，若出错则为-1
```
最后一个参数timeout，它告知内核等待所指定描述符中的任何个就绪可花多长时间。其timeval结构用于指定这段时间的秒数和微秒数。
```c
struct timeval {
    long tv_sec; /* seconds */
    long tv_usec; /* microseconds */
);
```
这个参数有以下三种可能。
- 用远等待下去:仅在有一个描述符准各好I/0时才返回。为此，我们把该参数设置为空指针。
- 等待一段固定时间:在有一个描述符准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。
- 根本不等待:检查描述符后立即返回，这称为轮询(polling)。为此，该参数必须指向一个timeval结构，而且其中的定时
器值(由该结构指定的秒数和微秒数)必须为0。

前两种情形的等待通常会被进程在等待期间捕获的信号中断，并从信号处理函数返回。

中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述符。
目前支持的异常条件只有两个:
- 某个套接字的带外数据的到达.
- 某个己置为分组模式的伪终端存在可从其主端读取的控制状态信息

所有这些实现细节都与应用程序无关，它们隐藏在名为fdset的数据类型
和以下四个宏中:
```c
void FD_ZERO(fd_set* fdset); /*clear all bits in fdset*/
void FD_SET(int fd,fd_set *fdset);  /*turn on the bit for fd in fdset*/
void FD_CUR(int fd,fd_set *fdset);  /*trun off the bit for fd in fdset*/
int FD_ISSET(int fd,fd_set *fdset); /*is the bit for fd on in fdset?*/
```

描述符集的初始化非常重要，因为作为自动变量分配的一个描达符集如果没有初始化，那么可能发生不可预期的后果。

select函数的中间三个参数readset、writeset和exceptset中，如果我们对某一个的条件不感兴趣，就可以把
它设为空指针。事实上，如果这三个指针均为空，我们就有了一个比Unix的sleep函数更为精确的定时器(sleep睡
眠以秒为最小单位)。poll函数提供类似的功能。

maxfdpl参数指定待测试的描述符个数，它的值是待测试的最大描达符加1(因此我们把该参数命名为maxfdpl)，
描述符0，1,2...一直到maxfdpl - 1均将被测试。

select函数修改由指针readset、writeset和exceptset所指向的的描述符集，因而这三个参数都是值-结果参数。
调用该函数时，我们了指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪。该两数返回后，我们使用
FD_ISSET宏来测试fd_set数据类型中的描述符。描述符集内任何与未就绪描达符对应的位返回时均清成0。为此，
每次重新调用select函数时，我们都得再次把所有描述符集内所关心的位均置为1。

使用select时最常见的两个编程错误是:忘了对最大描述符加1;忘了描述符集是值-结果参數。第二个错误导致调用select时，
描述符集内我们认为是1的位却被置为0。

## 1. 描述符就绪条件
满足下列四个条件中的任何一个时，一个套接字准备好读。
- 该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作
不会阻塞并将返回一个大于0的值(也就足返回准备好读入的数据)。我们可以使用SO_RCVLOWAT套接宇选项设置该套接
字的低水位标记。对于TCP和UDP套接字而言，其默认值为1。
- 该连接的读半部关闭(也就是接收了FIN的TCP连接)。对这样的套接字的读操作将不阻塞并返回0(也就是返回EOF)。
- 该套接字是一个监听套接字且己完成的连接数不为0。对这样的套接字的accept通常不会阻塞。
- 其上有一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1(也就是返回一个错误)，同时把errno设
置成确切的错误条件。这些待处理错误(pending error)也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。

下列四个条件中的任何一个满足时，一个套接字准备好写。
- 该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且或者该套接字已连接，或者
该套接字不需要连接(如UDP套接字)。这意味着如果我们把这样的套接字设置成非阻塞，写操作将不阻塞并返回一个正值(例如由
传输层接受的字节数)。我们可以使用SO_SNDLOWAT套接字选项来设置该套接字的低水位标记。对于TCP和UDP套接字而言，其默
认值通常为2048。
- 该连接的写半部关闭。对这样的套接字的写操作将产生SIGPIRE信号。
- 使用非阻塞式connect的套接宇己建立连接，或者connect己经以失败告终。
- 其上有一个套接字错误待处理。对这样的套接字的操作将不阻塞并返回-1(也就是返画一个错误)，同时把errno设置成确切的
错误条件。这些待处理的错误也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。

如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理。

注意:当某个套接字上发生错误时，它将由select标记为既可读又可写。

接收低水位标记和发送低水位标记的目的在于:允许应用进程控制在select返回可读或可写条件之前有多少数据可读或有
多大空间可用于写。举例来说，如果我们知道除非至少存在64个字节的数据，否则我们的应用进程没有任何有效工作可做，
那么可以把接收低水位标记设置为64，以防少于64个字节的数据准备好读时select唤醒我们。

任何UDP套接字只要其发送低水位标记小于等于发送缓冲区大小(默认应该总是这种关系)就总是可写的，这是因为UDP套接字不需要连接。

![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/select_socket_ready.jpg)




