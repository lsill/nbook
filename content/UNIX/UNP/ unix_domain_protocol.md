---
title: "Unix 域协议"
date: 2024-03-12T16:20:32+08:00
draft: true
---

## 1. 概述
Unix域协议并不是一个实际的协议族，而是在单个主机上执行客户/服务器通信的一种方法，所用API就是在不同主机上执行
客户/服务器通信所用的API(套接字API)。Unix域协议因此可视为IPC方法之一。

Unix城提供两类套接字:字节流套接字(类似TCP)和数据报套接字(类似DUP)。尽管也提供原始套接字，不过它的语义不曾见
于任何文档，未见过任何使用它的程序，POSIx也没有它的定义。

使用Unix城套接字有以下3个理由。
1. 在源自Berkeley的实现中，Unix域套接字往往比通信两端位于同一个主机的TCP套接字快出一倍。X Window System
发挥了Unix域套接字的这个优势。当一个X11客户启动并打开到X11服务器的连接时，该客户检查DISPLAY环境变量的值，其
中指定服务器的主机名、窗口和屏幕。如果服务器与容户处于同一个主机，客户就打开一个到服务器的Unix域字节流连接，否
则打开一个到服务器的TCP连接。
2. Unix域套接字可用于在同一个主机上的不同进程之间传递描达符。
3. Unix域套接字较新的实现把客户的凭证(用户ID和组ID)提供给服务器，从而能够提供额外的安全检查措施。Unix域中用于
标识客户和服务器的协议地址是普通文件系统中的路径名。IPv4协议地址由一个32位地址和一个16位端口号构成，IPv6协议地
址则由一个128位地址和一个16位端口号构成。这些路径名不是普通的Unix文件:除非把它们和Unix域套接字关联起来，否则无
法读写这些文件。

## 2. Unix域套接字地址结构
<sys/un.h>中定义的Unix域套接字地址结构
```c
struct sockaddr_un {
    sa_family_t sun_family; /* AF_LOCAL */
    char    sun_path [104]; /* null-terminated pathname */
};
```
存放在sun_path数组中的路径名必须以空字符结尾。实现提供的SUN_LEAN宏以一个指向sockaddr_un结构的指针为参数并返回该结构的
长度，其中包括路径名中非空字节数。未指定地址通过以空字符串作为路径名指示，也就是一个sun_path[0]值为0的地址结构。它等价于
IPv4的INADR_ANY常值以及IPv6的IN6ADDR_ANY_INIT常值。

## 3. socketpair 函数
socketpair函数创建两个随后连接起来的套接字。本函数仅适用于Unix域套接宇。
```c
#include<sys/socket.h>
int socketpair(int family,int type,int protocol,int sockfd[2]):
// 返回:若成功到为非0，若出错则为-1
```
family参数必须为AF_LOCAL，protocol参数必须为0。type参数既可以是SOCK_STREAM，也可以是SOCK_DGRAM。新创建的两个套接字
描述符作为sockfd[0]和sockfd[1]返回。

指定type参数为SOCK_STRAEM调用socketpair得到的结果称为流管道(stream pipe)。它与调用pipe创建的普通Unix管道类似，差别
在于流管道是全双工的，即两个描述符都是既可读又可写。图15-7展示了调用socketpair创建的流管道。

## 4. 套接字函数
当用于Unix域套接字时，套接字函数中存在一些差异和限制。我们尽量列出POSIX的要求，并指出并非所有实现目前都己达到这个级别。
1. 由bind创建的路径名默认访问权限应为0777(属主用户、组用户和其他用户都可读、可写并可执行)，并按照当前umask值进行修正。
2. 与Unix域套接字关联的路径名应该是一个绝对路径名，而不是一个相对路径名。避免使用后者的原因是它的解析依赖于调用者的当前
工作目录。也就是说，要是服务器捆绑一个相对路径名，客户就得在与服务器相同的目录中(或者必领知道这个目录)才能成功调用connect或sendto。
POSIX声称给Unix域套接字捆绑相对路径名将导致不可预计的结果。
3. 在connect调用中指定的路径名必须是一个当前绑定在某个打开的Unix城套接字上的路径名，而且它们的套接字类型(字节流或数据报)
也必须一致。出错条件包括:(a)该路径名己存在却不是一个套接字:(b〕该路径名己存在且是一个套接字，不过没有与之关联的打开的描述符:
(c)该路径名己存在且是一个打开的套接字，不过类型不符(也就是说Unix域字节流套接字不能连接到与Unix域数据报套接字关联的路径名，反之亦然)。
4. 调用connect连接一个Unix域套接字涉及的权限测试等同于调用open以只写方式访问相应的路径名。
5. Unix域字节流套接字类似TCP套接字:它们都为进程提供一个无记录边界的字节流接口。
6. 如果对于某个Unix域字节流套接字的connect调用发现这个监听套接字的队列己满，调用就立即返回一个BCONNREFUSED错误。这一点不同
于TCP:如果TCP监听套接字的队列己满，TCP监听端就忽略新到达的SYN，而TCP连接发起端将数次发送SYN进行重试。
7. Unix域数据报套接字类似于UDP套接字:它们都提供一个保留记录边界的不可靠的数据报服务。
8. 在一个末绑定的Unix域套接字上发送数据报不会自动给这个套接字捆绑一个路径名，这一点不同于UDP套接字:在一个未綁定的UDP套接字上发送UDP
数据报导致给这个套接字捆绑一个临时端口。这一点意味者除非数据报发送端已经捆绑一个路径名到它的套接字，否则数据报接收端无法发回应答数据报。
类似地，对于某个Unix域数据报套接字的connect调用不会给本套接字捆鄉一个路径名，这一点不同于TCP和UDP。

## 5. Unix域字节流客户/服务器程序
- [unixstrserv01](https://github.com/lsill/unpvnote/blob/main/unixdomain/unixstrserv01.c?plain=1#L4)
- [unixstrcli01](https://github.com/lsill/unpvnote/blob/main/unixdomain/unixstrcli01.c?plain=1#L4)

## 6. Unix域数据包客户/服务器程序
- [unixdgserv01](https://github.com/lsill/unpvnote/blob/main/unixdomain/unixdgserv01.c?plain=1#L4)
- [unixdgcli01](https://github.com/lsill/unpvnote/blob/main/unixdomain/unixdgcli01.c?plain=1#L4)

## 7. 描述符传递
当考虑从一个进程到另一个进程传递打开的描述符时，通常会想到:
- Fork调用返回之后，子进程共享父进程的所有打开的描述符:
- exec调用执行之后，所有描达符通常保持打开状态不变。

第一个例子中，进程先打开一个描述符，再调用fork，然后父进程关闭这个描述符，子进程则处理这个描述符。这样一个打开的
描述符就从父进程传递到子进程。然而我们也可能想让子进程打开一个描述符并把它传递给父进程。

当前的Unix系统提供了用于从一个进程向任一其他进程传递任一打开的描述符的方法。也就是说，这两个进程之间无需存在亲缘
关系，比如父子进程关系。这种技术要求首先在这两个进程之间创建—个Unix域套接字，然后使用sendmsg跨这个套接字发送一
个特殊消息。这个消息由内核来专门处理，会把打开的描述符从发送进程传递到接收进程。

在两个进程之间传递描达符涉及的步骤如下。
#### (1) 创建一个字节流的或数据报的Unix域套接字。
如果目标是fork一个子进程，让子进程打开待传递的描达符，再把它传递回父进程，那么父进程可以预先调用socketpair创建
一个可用于在父子进程之间交换描述符的流管道。

如果进程之间没有亲缘关系，那么服务器进程必须创建一个Unix域字节流套接字，bind一个路径名到该套接字，以允许客户进程
connect到该套接字。然后客户可以向服务器发送一个打开某个描述符的请求，服务器再把该描述符通过Unix域套接字传递回客
户。客户和服务器之间也可以使用Unix域数据报套接字，不过这么做没什么好处，而且数据报还存在被丢弃的可能性。在本节的
例子中，容户和服务器之间使用宇节流套接字。
#### (2) 
发送进程通过调用返回描述符的任一Unix函数打开一个描达符，这些函数的例子有open、pipe、mkfifo、socket和accept。
可以在进程之间传递的描述符不限类型，这就是我们称这种技术为“描述符传递”而不是“文件描达符传递”的原因。
#### (3) 
发送进程创建一个msghar结构，其中含有待传递的描述符。POSIX规定描述符作为辅助数据(msghdr结构的msg_control成员)
发送，不过较老的实现使用msg_accrights成员。发送进程调用sendmsg跨来自步骤1的Unix域套接字发送该描述符。至此我们
说这个描述符“在飞行中(in fight)”。即使发送进程在调用sendmsg之后但在接收进程调用recvmsg(见下一步骤)之前关闭了
该描述符，对于接收进程它仍然保持打开状态。发送一个描述符会使该描述符的引用计数加1。
#### (4) 
接收进程调用recvmsg在来自步骤1的Unix域套接字上接收这个描述符。这个描达符在接收进程中的描述符号不同于它在发送进程中
的描达符号是正常的。传递一个描达符并不是传递一个描达符号，而是涉及在接收进程中创建一个新的描述符，而这个新描述符和发
送进程中飞行前的那个描述符指向内核中相同的文件表项。

客户和服务器之间必须存在某种应用协议，以便描述符的接收进程预先知道何时期待接收。如果接收进程调用recvmsg时没有分配用
于接收描述符的空间，而且之前已有一个描述符被传递并正等着被读取，这个早先传递的描述符就会被关闭。另外，在期待接收描述
符的recvmsg调用中应该避免使用MSG_PEEK标志，否则后果不可预料。

**描述符传递的例子**
现在给出一个描述符传递的例子。这是一个名为mycat的程序，它通过命令行参数取得一个路径名，打开这个文件，再把文件的内容
复制到标准输出。该程序调用我们名为my_open的函数，而不是调用普通的Unix open函数。my_open创建一个流管道，并调用Fork
和exec启动执行另一个程序，期待输出的文件由这个程序打开。该程序随后必须把打开的描迏符通过流管道传递回父进程。

图15-7展示上述步骤(1):通过调用socketpair创建一个流管道后的mycat进程。我们以[0]和[1]标示socketpair返回的两个描述符。
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/15_7.jpg)
mycat进程接者调用fork，子进程再调用exec执行openfile程序。父进程关闭[1]描述符，子进程关闭[0]描述符。(流管道的两端之间
没有差异，我们也可以让子进程关闭[1]，让父进程关闭[0]。)图15-8展示了如此处理后的结果。
![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/unix/15_8.jpg)
父进程必须给openfile程序传递三条信息:(1)待打开文件的路径名，(2)打开方式(只读、读写或只写)，(3)流管道本进程端(图中标为
[1])对应的描述符号。我们选择将这三条信息作为命令行参数在调用exec时进行传递。当然我们也可以通过流管道将这三条信息作为数据
发送。openfile程序在通过流管道发送回打开的描述符后便终止。该程序的退出状态告知父进程文件能否打开，若不能则同时告知发生了
什么类型的错误。

通过执行另一个程序来打开文件的优势在于，另一个程序可以是一个setuid到root的程序，能够打开我们通常没有打开权限的文件。该程序
能够把通常的Unix权限概念(用户、用户组和其他用户，扩展到它想要的任何形式的访问检查。我们以mycat程序开始讨论，如图15-9所示。
- [mycat](https://github.com/lsill/unpvnote/blob/main/unixdomain/mycat.c?plain=1#L4)
- [myopen](https://github.com/lsill/unpvnote/blob/main/unixdomain/myopen.c?plain=1#L4)

下面给出了read_fd函数，它调用recvmsg在一个Unix域套接字上接收数据和描述符。该函数的前3个参数和read函数一样，第四个参数是指向
某个整数的指针，用以返回收取的描述符。
- [read_fd](https://github.com/lsill/unpvnote/blob/main/lib/read_fd.c?plain=1#L4)

下面给出了openfile程序。它取三个必须传入的命令行参数，并调用通常的open函数。
- [openfile](https://github.com/lsill/unpvnote/blob/main/unixdomain/openfile.c?plain=1#L4)

下面给出了最后一个函数的write_fd，它调用sendmsg跨一个Unix域套接字发送一个描述符(以及可选的数据，但本函数没有采用它们)。
- [write_fd](https://github.com/lsill/unpvnote/blob/main/lib/write_fd.c?plain=1#L4)

## 15.8 接收发送者的凭证
可通过Unix域套接字作为辅助数据传递的另一种数据是用户凭证。作为辅助数据的凭证其具体封装方式和发送方式往往特定于操作系统。
本节只讨论FreeBSD的凭证传递，不过其他Unix变体也是类似的(难点通常在确定使用哪个结构上)。凭证传递仍然是一个尚末普及且无
统一规范的特性，然而因为它是对Unix域协议的一个尽管简单却也重要的补充，所以我们还是要介绍一下它。当客户和服务器进行通信时，
服务器通常需以一定手段获悉客户的身份，以便验证客户是否有权限请求相应服务。

凭证信息总是可以通过Unix域套接字在两个进程间传递，然而发送进程发送它们时往往需做特殊的封裝处理，接收进程接收它们时也往往
需做特殊的接受处理(例如打开套接字选项)。在FreeBSD系统中，接收进程只需在调用recvmsg同时提供一个足以存放凭证的辅助数据空间即
可.

## 15.9 小结
Unix域套接字是客户和服务器在同一个主机上的IPC方法之一。与IPC其他方法相比，Unix域套接字的优势体现在其API几乎等同于网络
客户/服务器使用的API。与客户和服务器在同一个主机上的TCP相比，Unix域字节流套接字的优势体现在性能的增长上。

我们把自己的TCP和UDP回射客户和服务器程序修改成了使用Unix域协议的版本，其中唯一的主要差别是:必须bind一个路径名到UDP套接
字(对应Unix域数据报套接字)的客户，以使UDP服务器有发送应答的目的地。

同一个主机上客户和服务器之间的描述符传递是一个非常有用的技术，它通过Unix域套接字发生。























