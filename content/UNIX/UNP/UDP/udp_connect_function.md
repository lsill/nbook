---
title: "UDP的connect函数"
date: 2023-12-27T18:17:22+08:00
draft: true
---

除非套接字已连接，否则异步错误是不会返回到UDP套接字的。我们确实可以给UDP套接字调用connect，然而
这样做的结果却与TCP连接大相径庭:没有三路握手过程。内核只是检查是否存在立即可知的错误(例如一个显然
不可达的目的地)，记录对端的IP地址和端口号(取自传递给connect的套接字地址结构)，然后立即返回到调用
进程。

有了这个能力后，我们必须区分:
- 未连接UDP套接字(unconnected UDP socket)，新创建UDP套接字默认如此;
- 己连接UDP套接字(connected UDP socket)，对UDP套接字调用connect的结果。

对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。

(1)我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto,而改用write或send。
写到己连接UDP套接宇上的任何内容都自动发送到由connect指定的协议地址(例如IP地址和端又号〕。
(其实我们可以给已连接UDP套接宇调用sendto，但是不能指定目的地址。sendto的第五个参数(指向指明目的
地址的套接字地址结构的指针)必须为空指针，第六个参数(该套接字地址结构的大小)应该为0。POSIX规范指出
当第五个参数是空指针时，第六个参數的取值就不再考虑)

(2)我们不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个己连接UDP套接字上，
由内核为输入操作返回的数据报只有那些来自connect所指定协议地址的数据报。目的地为这个已连接UDP套接字
的本地协议地址(例如IP地址和端口号)，发源地却不是该套接字早先connect到的协议地址的数据报，不会投递到
该套接字。这样就限制一个己连接UDP套接字能且仅能与一个对端交换数据报。
（确切地说，一个已连接UDP套接字仅仅与一个IP地址交换數据报，因为connect到多播或广播地址是可能的。）

(3)由己连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接UDP套接字不接收任何异步错误。

UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的
通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信(如TFTP)，这种情况下，客户和服务器都可能调用
connect。

## 1. 给一个UDP套接字多次调用connect
拥有一个己连接UDP套接字的进程可出于下列两个目的之一再次调用connect:
- 指定新的IP地址和端口号;
- 断开套接字。

第一个目的(即给一个已连接UDP套接字指定新的对端)不同于TCP套接字中connect的使用:对于TCP套接字，connect只能调用
一次。

为了断开一个已UDP套接字连接，我们再次调用connect时把套接字地址结构的地址族成员(对于IPv4为sin_family，对于IPV6
为sin6_family)设置为AF_UNSPEC。这么做可能会返回一个EAFNOSUPORT错误，不过没有关系。使套接字断开连接的是在己连
接UDP套接字上调用connect的进程。

## 2. 性能
当应用进程在一个末连接的UDP套接字上调用sendto时，源自Berkcley的内核暂时连接该套接字，发送数据报，然后断开该连接。
在一个未连接的UDP套接字上给两个数据报调用sendto函数于是涉及内核执行下列6个步骤:
- 连接套接字;
- 输出第一个数据报;
- 断开套接字连接;
- 连接套接字:
- 输出第二个数据报:
- 断开套接字连接。

(另一个考虑是搜索路由表的次數。第一次临时连接需为目的IP地址搜索路由表并高速缓存这条信息。第二次临时连接注意到目的
地址等于已高速级存的路由表信息的目的地(我们假设这两个sendto调用有相同的目的地址)，于是就不必再次查找路由表。)

当应用进程知道自己要给同一目的地址发送多个数据报时，显式连接套接字效率更高。调用connect后调用两次write涉及内核执行如下步骤:
- 连接套接字;
- 输出第一个数据报；
- 输出第二个数据报。

在这种情况下，内核只复制一次含有目的IP地址和口又号的套接字地址结构，相反当调用两次sendto时，需复制两次。临时连接末连接的UDP
套接字大约会粍费每个UDP传输三分之一的开销。





