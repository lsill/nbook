---
title: " 编译期多态：泛型编程和模板入门"
date: 2023-02-28T17:32:12+18:00
draft: true
---

**现代C++实战30讲笔记**

### 面向对象和堕胎
在面向对象的开发里，最基本的一个特性就是“多态” ——用相同的代码得到不同结果。

shape 类为例，它可能会定义一些通用的功能，然后在子类里进行实现或覆盖：
```c++
class shape {
public:
  …
  void draw(const position&) = 0;
};
```
上面的类定义意味着所有的子类必须实现 draw 函数，所以可以认为 shape 是定义了一个接口（按 Java 的概念）。在面向对象的设计里，接口抽象了一些基本的行为，实现类里则去具体实现这些功能。当我们有着接口类的指针或引用时，我们实际可以唤起具体的实现类里的逻辑。比如，在一个绘图程序里，我们可以在用户选择一种形状时，把形状赋给一个 shape 的（智能）指针，在用户点击绘图区域时，执行 draw 操作。根据指针指向的形状不同，实际绘制出的可能是圆，可能是三角形，也可能是其他形状。

但这种面向对象的方式，并不是唯一一种实现多态的方式。在很多动态类型语言里，有所谓的“鸭子”类型 :

    如果一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那么这只鸟就可以被当作鸭子。

在这样的语言里，你可以不需要继承来实现 circle、triangle 等类，然后可以直接在这个类型的变量上调用 draw 方法。如果这个类型的对象没有 draw 方法，你就会在执行到 draw() 语句的时候得到一个错误（或异常）。

鸭子类型使得开发者可以不使用继承体系来灵活地实现一些“约定”，尤其是使得混合不同来源、使用不同对象继承体系的代码成为可能。唯一的要求只是，这些不同的对象有“共通”的成员函数。这些成员函数应当有相同的名字和相同结构的参数（并不要求参数类型相同）。

### 容器类的共性
容器类是有很多共性的。其中，一个最最普遍的共性就是，容器类都有begin和end成员函数————这使得通用地遍历一个容器成为可能。容器类不必继承一个共同的Container基类，而仍然可以写出通用的遍历容器的代码，如使用基于范围的循环。

大部分容器是有size成员函数的，在“泛型”编程中，同样可以取的一个容器的大小，而不要求容器继承一个叫SizeableContainer的基类。

很多容器具有push_back成员函数，可以在尾部插入数据。同样，不需要一个叫BackPushableContainer的基类。在这里例子里，push_back函数的参数显然是都不一样的，但明显，所有的push_back函数都只接收一个参数。

可以清晰看到的是，虽然c++的标准容器没有对象继承关系，但彼此之前有着很多的同构性。这些同构性很难用继承体系来表达，也完全不必要用继承来表达。C++的模版，已经足够表达这些鸭子类型。

当然，作为一种静态类型语言，C++是不会在运行时才报告“没找到draw方法”这类问题的。这类错误可以在编译时直接捕获，更精确的说，是在模版实力话的过程中。

## C++ 模版

### 定义模版
求最大公约数的辗转相除法，代码大致如下：
```c++
int my_gcd(int a, int b)
{
  while (b != 0) {
    int r = a % b;
    a = b;
    b = r;
  }
  return a;
}
```

这里只有一个小小的问题，C++ 的整数类型可不止 int 一种啊。为了让这个算法对像长整型这样的类型也生效，需要把它定义成一个模板：
```c++
template<typename E>
E my_gcd(E a, E b) {
  while(b != E(0)) {
    int r = a % b;
    a = b;
    b = r;
  }
  return a;
}
```

这个代码里，基本上就是把 int 替换成了模板参数 E，并在函数的开头添加了模板的声明。对于“整数”这只鸭子的要求实际上是：
- 可以通过常量0来构造
- 可以拷贝（构造和赋值）
- 可以做不等于比较
- 可以进行取余操作

对于标准的 int、long、long long 等类型及其对应的无符号类型，以上代码都能正常工作，并能得到正确的结果。

### 实例化模版
不管是类模板还是函数模板，编译器在看到其定义时只能做最基本的语法检查，真正的类型检查要在实例化（instantiation）的时候才能做。一般而言，这也是编译器会报错的时候。

对于上面 my_gcd 的情况，如果提供的是一般的整数类型，那是不会有问题的。但如果提供一些其他类型的时候，就有可能出问题了。以 CLN，一个高精度数字库为例（注：并不推荐使用这个库），如果使用它的 cl_I 高精度整数类型来调用 my_gcd 的话，会出错，其原因是，虽然它的整数类 cl_I 设计得很像普通的整数，但这个类的对象不支持 % 运算符。

实例化失败的话，编译当然就出错退出了。如果成功的话，模板的实例就产生了。在整个的编译过程中，可能产生多个这样的（相同）实例，但最后链接时，会只剩下一个实例。这也是为什么 C++ 会有一个单一定义的规则：如果不同的编译单元看到不同的定义的话，那链接时使用哪个定义是不确定的，结果就可能会让人吃惊。

模板还可以显式实例化和外部实例化。如果在调用 my_gcd 之前进行显式实例化——即，使用 template 关键字并给出完整的类型来声明函数：
```c++
template cln::cl_I
  my_gcd(cln::cl_I, cln::cl_I);
```
那出错信息中的第二行就会显示要求实例化的位置。如果在显式实例化的形式之前加上 extern 的话，编译器就会认为这个模板已经在其他某个地方实例化，从而不再产生其定义（但代码用到的内联函数仍可能会导致实例化的发生，这个会随编译器和优化选项不同而变化）。在我们这个例子里，就意味着不会产生上面的编译错误信息了。当然，仍然会在链接时得到错误，因为并没有真正实例化这个模板。

类似的，当在使用 vector<int> 这样的表达式时，就在隐式地实例化 vector<int>。同样也可以选择用 template class vector<int>; 来显式实例化，或使用 extern template class vector<int>; 来告诉编译器不需要实例化。显式实例化和外部实例化通常在大型项目中可以用来集中模板的实例化，从而加速编译过程——不需要在每个用到模板的地方都进行实例化了——但这种方式有额外的管理开销，如果实例化了不必要实例化的模板的话，反而会导致可执行文件变大。因而，显式实例化和外部实例化应当谨慎使用。

### 特化模版
如果遇到像前面 CLN 那样的情况，需要使用的模板参数类型，不能完全满足模板的要求，应该怎么办？
- 添加代码，让那个类型支持所需要的操作（对成员函数无效）
- 对于函数模版，可以直接针对那个类型进行重载
- 对于类模版和函数模版，可以针对那个类型进行特化

对于 cln::cl_I 不支持 % 运算符这种情况，恰好上面的三种方法都可以用。
一、添加 operator% 的实现：
```c++
cln::cl_I
operator%(const cln::cl_I& lhs,
          const cln::cl_I& rhs)
{
  return mod(lhs, rhs);
}
```
在这个例子，这可能是最简单的解决方案了。但在很多情况下，尤其是对对象的成员函数有要求的情况下，这个方法不可行。

二、针对 cl_I 进行重载：
为通用起见，不直接使用 cl_I 的 mod 函数，而用 my_mod 把 my_gcd 改造如下：
```c++
template <typename E>
E my_gcd(E a, E b)
{
  while (b != E(0)) {
    E r = my_mod(a, b);
    a = b;
    b = r;
  }
  return a;
}
```
然后，一般情况的 my_mod 显然就是：
```c++
template <typename E>
E my_mod(const E& lhs,
         const E& rhs)
{
  return lhs % rhs;
}
```
最后，针对 cl_I 类，我们可以重载（overload）：
```c++
cln::cl_I
my_mod(const cln::cl_I& lhs,
       const cln::cl_I& rhs)
{
  return mod(lhs, rhs);
}
```
三、针对 cl_I 进行特化：
同二类似，但提供的不是一个重载，而是特化（specialization）：
```c++
template <>
cln::cl_I my_mod<cln::cl_I>(
  const cln::cl_I& lhs,
  const cln::cl_I& rhs)
{
  return mod(lhs, rhs);
}
```
这个例子比较简单，特化和重载在行为上没有本质的区别。就一般而言，特化是一种更通用的技巧，最主要的原因是特化可以用在类模板和函数模板上，而重载只能用于函数。

不过，只是展示了一种可能性而已。通用而言，Herb Sutter 给出了明确的建议：**对函数使用重载，对类模板进行特化**。

展示特化的更好的例子是 C++11 之前的静态断言。使用特化技巧可以大致实现 static_assert 的功能：
```c++
template<bool>
struct compile_time_error;
template<>
struct compile_time_error<true>{};

#define STATIC_ASSERT(Expr, Msg)    \
  {                                 \
    compile_time_error<bool(Expr)>  \
      ERROR_##_Msg;                 \
    (void)ERROR_##_Msg;             \
  }                                 \

```
上面首先声明了一个struct模版，然后仅对true的情况进行了特化，产生了一个struck的定义。这样如果遇到compile_time_error<false> 的情况——也就是下面静态断言里的Expr不为真的情况——编译器就会失败报错，因为compile_time_error<false> 从来就没有被定义过。

### “动态”多态和“静态”多态的对比
前面描述了面向对象的“动态”多态，也描述了 C++ 里基于泛型编程的“静态”多态。需要看到的是，两者解决的实际上是不太一样的问题。“动态”多态解决的是运行时的行为变化————就如前面提到的，选择了一个形状之后，再选择在某个地方绘制这个形状——这个是无法在编译时确定的。“静态”多态或者“泛型”——解决的是很不同的问题，让适用于不同类型的“同构”算法可以用同一套代码来实现，实际上强调的是对代码的复用。C++ 里提供了很多标准算法，都一样只作出了基本的约定，然后对任何满足约定的类型都可以工作。以排序为例，C++ 里的标准 sort 算法（以两参数的重载为例）只要求：
- 参数满足随机访问迭代器的要求
- 迭代器指向的对象之间可以使用<来比较大小，满足严格弱序关系。
- 迭代器指向的对象可以被移动。

它的性能超过C的qsort，因为编译器可以内联对象的比较操作；而在C里面比较只能通过一个额外的函数调用来实现。此外C的qsort函数要求数组指向的内容是可按比特赋值的，C++的sort则要求迭代器指向的内容是可移动的，可适用于更广的情况。

C++里目前有大量这样的泛型算法，列举几个：
- sort 排序
- reverse 反转
- count 计数
- find 查找
- max 最大值
- min 最小值
- minmax 最大值和最小值
- next_permutation 下一个排列
- gcd 最大公约数
- lcm 最小公倍数
- 等等

