---
title: "异常用还是不用"
date: 2023-02-14T19:18:25+18:00
draft: true
---

### 没有异常的世界
没有异常的最典型情况就是C了。
假设我们要做一些矩阵的操作，定义了下面这个矩阵的数据结构：
```c
typedef struct {
  float* data;
  size_t n_rows;
  size_t n_cols;
} matrix;
```
至少需要初始化和清理的代码：
```c
enum matrix_err_code {
  MATRIX_SUCCESS,
  MATRIX_ERR_MEMORY_INSUFFICIENT,  // 内存不足
  MATRIX_ERR_MISMATCHED_MATRIX_SIZE,
};

int matrix_alloc(matrix* ptr, size_t n_rows, size_t n_cols) {
  size_t size = n_rows * n_cols * sizeof(float );
  float* data = static_cast<float*>(malloc(size)) ;
  if (data == NULL) {
    return MATRIX_ERR_MEMORY_INSUFFICIENT;
  }
  ptr->data = data;
  ptr->n_rows = n_rows;
  ptr->n_cols = n_cols;
}

void matrix_dealloc(matrix* ptr) {
  if (ptr->data == NULL) {
    return;
  }
  free(ptr->data);
  ptr->data = NULL;
  ptr->n_cols = 0;
  ptr->n_rows = 0;
}
```
然后做一下矩阵乘法：
```c
int matrix_multiply(matrix* result, const matrix* lhs, const matrix* rhs) {
  int errcode;
  if (lhs->n_cols != rhs->n_rows) {
    return MATRIX_ERR_MISMATCHED_MATRIX_SIZE;
  }
  errcode = matrix_alloc(result, lhs->n_rows, rhs->n_cols);
  if (errcode != MATRIX_SUCCESS) {
    return errcode;
  }
  return MATRIX_SUCCESS;
}
```
调用代码：
```c
  matrix c;
  // 不清零的话，错误处理和资源清理会更复杂
  memset(&c, 0, sizeof(matrix));

  int errcode = 0;
  errcode = matrix_multiply(c, a, b);
  if (errcode != MATRIX_SUCCESS) {
    goto error_exit;
  }
  error_exit:
    matrix_dealloc(&c);
    return errcode;
```
可以看到，有大量需要判断错误的代码，零散分布在代码各处。
C++不用异常可以吗？
当然可以，但结果好不了多少。毕竟C++的构造函数是不能返回错误吗的，所以根本不能用构造函数来做可能出错的事情。不得不定义一个只能清零的构造函数，在使用一个init函数来做真正的构造操作。C++虽然支持运算符重载，可也不能使用，因为没法返回一个矩阵。
上面还只展示了单层的函数调用。事实上，如果出错位置离处理错误的位置相差很远的话，每一层函数调用里都有判断错错误码的代码，这就既对写代码的人提出了严格要求，也对读代码的人造成了视觉上的干扰。

### 使用异常
如果使用异常的话，就可以在构造函数里做真正的初始化工作了。假设矩阵有下列的数据成员：
```c++
class matrix {
 private:
  float* data_;
  size_t nrows_;
  size_t ncols_;
 public:
  matrix(size_t nrows, size_t ncols);
  ~matrix();
  friend matrix
  operator*(const matrix&, const matrix&);
};
```
构造函数可以这样写：
```c++
matrix::matrix(size_t nrows, size_t ncols) {
  data_ = new float[nrows * ncols];
  nrows_ = nrows;
  ncols_ = ncols;
}
```
析构非常简单：
```c++
matrix::~matrix() {
  delete[] data_;
}
```
乘法函数可以这样写：
```c++
matrix operator*(const matrix& lhs, const matrix& rhs) {
  if (lhs.ncols_ != rhs.nrows_) {
    throw std::runtime_error(
        "matrix sizes mismatch"
        );
  }
  matrix result(lhs.nrows_, rhs.ncols_);
  // 进行矩阵乘法运算
  return result;
}
```
使用乘法的代码更加简单：
```
matrix c = a * b;
```
错误处理在哪？只有一个throw，和前面的C能等价吗？
异常处理并不意味着要写显示的try和catch。**异常安全的代码，可以没有任何try和catch**
如果不确定什么事“异常安全”，先来温习一下概念：**异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。**