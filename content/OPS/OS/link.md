---
title: "连接"
date: 2023-11-23T16:49:48+08:00
draft: true
---

# 连接
`链接(linking)`是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。
链接可以执行于编译时(compile time)，也就是在源代码被翻译成机器代码时;
也可以执行于加载时(load time)，也就是在程序被加载器(loader)加载到内存并执行时;
甚至执行于运行时(run time)，也就是由应用程序来执行。
在早期的计算机系统中，链接是手动执行的。
在现代系统中，链接是由叫做链接器(linker)的程序自动执行的。

理解连接作用:

- 理解连椄器将帮助你构造大型程序
- 理解链接器将帮助你避免一些危险的编程错误
- 理解链椄将帮助你理解语言的作用域规则是如何实现的
- 理解链接将帮助你理解其他重要的系统概念
- 理解链接将使你能够利用共享库

## 1. 编译器驱动程序
两个.c文件，main.c和sum.c， 要将sum.c连接到main.c

linux>gcc -Og -o prog main.c sum.c

将main.c翻译成一个ASCII的中间文件main.i:  cpp [other arguments] main.c /tmp/main.i

驱动器运行c编译器（cc1）将.main.i翻译成一个ASCII编码语言文件main.s:  cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s

驱动器运行汇编器(as)将main.s翻译成一个可重定位目标文件main.o:   as [other arguments] -o /tmp/main.o /tmp main.s

经过相同过程生成sum.o

运行链接器程序ld，将main.o和sum.o以及一些必要的系统文件组合起来，创建一个可执行的目标文件prog：
ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o

执行文件：linux>./prog


shell调用操作系统中一个叫做加载器(loader)的两数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。


## 2. 静态连接
像LinuxLD程序这样的静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输人，
生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输人的可重定位目标文件由各种不同
的代码和数据节(section)组成，每一节都是一个连线的宇节序列。

为了构造可执行文件，链接器必须完成两个主要任务:
- 符号解析(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、
一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。符号解析的目的是
将每个符号引用正好和一个符号定义关联起来。
- 重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每
个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使
得它们指向这个内存位置。链接器使用汇编器产生的重定位条目(relocation entry)的详细
指令，不加甄别地执行这样的重定位。

目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则
包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，
并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇
编器已经完成了大部分工作。

## 3. 目标文件
目标文件有三种形式：
- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，
创建一个可执行目标文件。
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

编译器和汇编器生成可重定位目标文件(包括共享目标文件)。
链接器生成可执行目标文件。
从技术上来说，一个目标模块(object module)就是一个字节序列，
而一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块


## 4. 可重定位目标文件
一个典型的ELF可重定位目标文件的格式。ELF头(ELF header)以一个16字节的序列开始，这个序列描述了生成该文件
的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其 中包括ELF头的大小、
目标文件的类型(如可重定 位、可执行或者共享的)、机器类型(如x86-64)、头部表(section header table)的文件
移，以及节部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固 定大小
的条目(entry)。

- .text:已编译程序的机器代码。
- .rodata:只读数据，比如printf语句中的格式串和开关语句的跳转表。
- .data:已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。
- .bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，
它仅仅是一个占位符。目标文件格式区分己初始化和未初始化变量是为了空间效率:在目标文件中，未初始化变量不需要占据
任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。
- .symtab:一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来
编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表(除非程序员特意用
STRIP命令去掉它)。然而，和编译器中的符号表不同，symtab符号表不包含局部变量的条目。
- .rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，
任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标
文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
- .rel.data:被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是
一个全局变量地址或者外部定义西数的地址，都需要被修改。
- .debug:一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源
文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。
- .line:原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表。
- .strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null
结尾的字符串的序列。

## 5. 符号和符号表
每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号:
- 由模块m定义并能被其他模块引用的`全局符号`。全局链接器符号对应于非静态的C两数和全局变量。
- 由其他模块定义并被模块m引用的`全局符号`。这些符号称为`外部符号`，对应于在其他模块中定义的非静态C两数和全局变量。
- 只被模块m定义和引用的`局部符号`。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，
但是不能被其他模块引用。

认识到本地链接器符号和本地程序变量不同是很重要的。.symtab中的符号表不包含对应于本地非静态程序变量的任何符号。
这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。

符号表是由汇编器构造的，使用编译器输出到汇编语言•s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。
```c
typedef struct { 
    int name;   /* String table offset */
    char type:4,    /*Function or data(4 bits) */
         binding:4; /* Local or global (4 bits) */
    char reserved;  /* Unused */
    short section;  /* Section header index */
    long value; /* Section offset or absolute address */ 
    long size; /* Object size in bytes */
} Elf64_Symbol;
```

- name是字符串表中的宇节偏移，指向符号的以null结尾的宇符串名字。
- value是符号的地址。对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。
对于可执行目标文件来说，该值是一个绝对运行时地址。
- size是目标的大小(以字节为单位)。
- type通常要么是数据，要么是函数。
- binding字段表示符号是本地的还是全局的。

## 6. 符号解析
链接器解析符号引用的方法是将每个引用与它输人的可重定位目标文件的符号表中的一个确定的符号定义关联起来。
对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。
编译器只允许每个模块中每个局部符号有一个定义。
静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。

不过，对全局符号的引用解析就辣手得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，
会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在
它的任何输人模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。

全局符号的符号解析很辣手，还因为多个目标文件可能会定义相同名字的全局符号。
在这种情况中，链接器必领要么标志一个错误，要么以某种方法选出一个定义并拋弃其他定义。
Linux系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能给不警觉的程序员带来一些麻烦

### 1. 链接器如何解析多重定义的全局符号
链接器的输人是一组可重定位目标模块。每个模块定义一组符号，有些是局部的(只对定义该符号的模块可见)，
有些是全局的(对其他模块也可见)。

在编译时，编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak)，而汇编器把这个信息隐含地
编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名:
- 规则1：不允许有多个同名的强符号
- 规则2：如果有一个强符号和多个若符号同名，那么选择强符号
- 规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个

规则2和3的应用会导致一些错误，比如定义了两个不同类型同名的全局变量，只会给出警告。

### 2. 与静态库连接
实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为`静态库(static library)`，
它可以用做链接器的输人。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，
有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后级.a标识。

举例：
有两个.c文件addvec.c 和 multvec.c
1. 使用AR工具创建函数的一个静态库
linux>gcc -c addvec.c multvec.c
linux>ar rcs libvector.a addvec.o multvec.o
2. （main2.c 调用addvec库例程，main2.c包含vector.h）编译和连接输入文件main.o和libvector.a
linux>gcc -c main2.c
linux>gcc -static -o prog2c main.0 ./libvector.a
或者等价使用
linux>gcc -c main2.c
linux>gcc -static -o -prog2c main2.o -L -lvector

当链接器运行时，它判定main2.0引用了addvec.o定义的addvec符号，所以复制addvec.o到可执行文件。
因为程序不引用任何由multvec.o定义的符号，所以链接器就不会复制这个模块到可执行文件。
链接器还会复libc.a中的printf.o模块，以及许多C运行时系统中的其他模块。

### 3. 链接器如何使用静态库来解析引用
虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于Linux链接器使用它们解析外部引用的方式。
在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。
(驱动程序自动将命令行中所有的.c文件翻译为.o文件。)在这次扫描中，链接器维护一个可重定位目标文件的
集合E(这个集合中的文件会被合并起来形成可执行文件)，一个未解析的符号(即引用了但是尚未定义的符号)集合U，
以及一个在前面输人文件中已定义的符号集合D。初始时，E、U和D均为空。


- 对于命令行上的每个输人文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，
那么链接器把f添加到E，修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。
- 如果f是一个存档文件，那么链接器就尝试匹配U中木解析的符号和由存档文件成员定义的符号。
如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器
修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到
U和D都不再发生变化。此时，任何不包含在E中的成员目标文件都简单地被丟弃，而链接器将继续处理下一个输人文件。
- 如果当链接器完成对命令行上输人文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。
否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。

关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的(也就是说没有成员引用另一个
成员定义的符号)， 那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库不是相互独立的，
那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在
对s的引用之后的。比如，假设foo.c调用libx.a和libz.a中的函数，而这两个库又调用liby.a中的函数。
那么，在命令行中libx.a和libz.a必须处在liby.a之前:

linux>gcc foo.c libx.a libz.a liby.a

如果需要满足依赖需求，可以在命令行上重复库。比如，假设foo.c调用libx.a中的函数，
该库又调用liby.a中的函数，而liby.a又调用libx.a中的函数。那么libx.a必须在命令行上重复出现:

linux>gcc foo.c libx.a liby.a libx.a

另一种方法是，我们可以将1ibx.a和1iby•a合并成一个单独的存档文件

## 7. 重定位
一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义(即它的一个输入目标
模块中的一个符号表条目)关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。
现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成:
- 重定位节和符号定义。
在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节
被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给
新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的
每条指令和全局变量都有唯一的运行时内存地址了
- 重定位节中的符号引用
在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。
要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目(relocation entry)的数据结构，
我们接下来将会描述这种数据结构。

### 1. 重定位条目
当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道
这个模块引用的任何外部定义函数数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置
未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何
修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在。rel.data中。

```c
typedef struct {
    long offset; /*Offset of the reference to relocate */ 
    long type:32, /*Relocation type */
         symbol:32; /*Symbol table index */
    long addend; /* Constant part of relocation expression */
} Elf64_Rela;
```
- offset是需要被修改的引用的节偏移。
- symbol标识被修改引用应该指向的符号。
- type告知链接器如何修改新的引用。
- addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

ELF定义了32种不同的重定位类型，有些相当隐秘。我们只关心其中两种最基本的重定位类型:
- Rx86_64_PC32。重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距
程序计数器(PC)的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，
它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址(如call指令
的目标)，PC值通常是下一条指令在内存中的地址。
- Rx86_64_32。重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用
在指令中编码的32位值作为有效地址，不需要进一步修改。

这两种重定位类型支持x86-64小型代码模型(small code model)，该模型假设可执行
目标文件中的代码和数据的,总体大小小于2GB，因此在运行时可以用32位PC相对地址来
访问。GCC默认使用小型代码模型。大于2GB的程序可以用-mcmodel=medium(中型代码
模型)和-mcmodel-large(大型代码模型)标志来编译，不过在此我们不讨论这些模型。

### 2. 重定位符号引用
```
foreach section s { // 每个节s
    foreach relocation entry r {    // 每个重定位条目r
        refptr = s + r.offset;  /* ptr to reference to be relocated */ // 计算重定位的4字节引用的数组s中的地址
        /* Relocate a PC-relative reference */  // PC相对寻址
        if (r.type == R_X86_64_PC32) {
            refaddr = ADDR(s) + r.offset;   /* ref's run-time address */
            *refptr = (unsigned)(ADDR(r.symbol) + r.addend - refaddr);
        }
        /* Relocate an absolute reference */    // 绝对寻址
        if (r.type == R_X86_64_32) {
            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);
        }
    }
}
```

举例（汇编）：
```
0000000000000000<main>:
    0:  48 83 ec 08             sub $0x8, %rsp
    4:  be 02 00 00 00          mov $0x2, %esi  
    9:  bf 00 00 00 00          mov $0x0, %edi  // %edi = &array
                        a: R_X86_64_32 array
    e:  e8 00 00 00 00          callq 13, <main+0x13>   // sum()
                        f: R_X86_64_PC_32 sum-0x4
    13: 48 83 c4                add $0x8, %rsp
    17: c3                      retq
```

1. 重定位PC相对引用
函数main调用sum函数，sum西数是在模块sum.o中定义的。call指令开始于节偏移Oxe的地方，
包括1字节的操作码0xe8，后面跟着的是对目标sum的32位PC相对引用的占位符。

相应的重定位条目r由4个字符组成：
- r.offset = 0xf 
- r.symbol = sum
- r.type = R_X86_64_PC_32
- r.addend = -4

这些字段告诉链接器修改开始于偏移量Oxf处的32位PC相对引用，这样在运行时它会指向sum例程 。
现在，假设链接器已经确定

ADDR(s) = ADDR(.text) = 0x4004d0 和 ADDR(s.symbol) = ADDR(sum) = 0x4004e8

计算出引用的运行时地址：

refaddr = ADDE(s) + r.offset = 0x4004d0 + 0xf = 0x4004df

更新该引用，使得它在运行时指向sum程序：

*refptr = (unsigned)(ADDR(r.symbol)+r.addend-refaddr) = (unsigned)(0x4004e8 + (-4) - 0x4004df) = (unsigned)(0x5)

在得到的可执行目标文件中，call指令有如下的重定位形式：

3004de: e8 05 00 00 00  callq 4004e8<sum> // sum()

在运行时，call指令将存放在地址0x4004de处。当CPU执行call指令时，PC的值为0x4004e3，
即紧随在call指令之后的指令的地址。为了执行这条指令，CPU执行以下的步骤:
- 将PC压入栈中
- PC <- PC + 0x5 = 0x4004e3 + 0x5 = 0x4004e8
  
因此，要执行的下一条指令就是sum例程的第一条指令，这当然就是我们想要的

### 2. 重定位绝对引用
重定位绝对引用相当简单。mov指令将array的地址(一个32位立即数值)复制到奇存器%edi中。
mov指令开始于节偏移量0x9的位置，包括1宇节操作码oxbf，后面跟着对array的32位绝对引用的占位符。
对应的占位符条目工包括4个字段:
- r.offset = 0xa
- r.symbol = array
- r.type = R_X86_64_32
- r.addend = 0

这些字段告诉链接器要修改从偏移量0xa开始的绝对引用，这样在运行时它将会指向array的第一个字节。
现在，假设链接器己经确定

ADDR(r.symbol) = ADDR(array) = 0x601018

链接器修改引用：

*refptr = (unsigned)(ADDR(r.symbol) + r.addend)=(unsigned)(0x601018 + 0) = (unsigned)(0x601018)

得到可执行目标文件中，引用有下面的重定位：

4004d9: bf 18 10 60 00  mov $0x606018, %edi

## 8. 可执行文件
二进制文件：

| 名称                                              | 在哪              |
|-------------------------------------------------|-----------------|
| ELF头，段头部表（将连续的文件节映射到运行时内存段），.init,.text,.rodata | 只读内存段（代码段）      |
| .data,.bss                                      | 读/写内存段（数据段）     |
| .symtab,.debug,.line.strtab,节头部表（描述目标文件的节）      | 不加载到内存的符号表和调试信息 |

执行目标文件的格式类似于可重定位目标文件的格式。ELF头描述文件的总体格式。它还包括程序
的入口点(entry point)，也就是当程序运行时要执行的第一条指令的地址。.text、.rodata
和.data节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时
内存地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可
执行文件是完全链接的(已被重定位)，所以它不再需要.rel节。

ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射，到连续的内存段。
程序头部表(program header table)描述了这种映射关系。可执行文件prog的程序头部表，是由OBJDUMP显示的。

// code/link/prog-exe.d
```
// read-only code segment
1. LOAD off 0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21
2.      filesz 0x000000000000069c memsz 0x000000000000069c flags r-x
// Read/Write data segment
3. LOAD off 0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21
4.    filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw-
```
// code/link/prog.exe.d

- off:目标内存中的偏移
- vaddr/paddr: 内存地址
- align: 对齐要求
- filesz: 目标文件中段大小
- memsz：内存中的段大小
- flags: 运行时访问权限

第一行和第2行告诉我们第一个段(代码段)有读/执行访问权限，开始于内存地址0x400000处，总共的内存大小
是0x69c字节，并且被初始化为可执行目标文件的头0x69c个字节，其中包括ELF头、程序头部表以及
.init、.text和.rodata节。

第3行和第4行告诉我们第二个段(数据段)有读/写访问权限，开始于内存地址0x600df8处，
总的内存大小为0x230字节，并用从目标文件中偏移Oxdf8处开始的.data节中的ox228个
字节初始化。该段中剩下的8个字节对应于运行时将被初始化为0的.bss数据。

对于任何段s，链接器必须选择一个起始地址vaddr，使得

vaddr mod align = off mod align

这里，off是目标文件中段的第一个节的偏移量，align是程序头部中指定的对齐(21=0x200000)。

例如：vaddr mod align = 0x600df8 mod 0x200000 = 0xdf8  以及 off mod align = 0xdf8 mod 0x200000 = 0xdf8

这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中。
原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大小为2的幂的字节片。

## 9. 加载可执行目标文件

## 10. 动态连接共享库
共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，
在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。
这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器(dynamic linker)
的程序来执行的。共享库也称为共享目标(shared object)，在Linux系统中通常用.so后缀来表示。
微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)。

调用编译器驱动程序：

linux>gcc -shared -fpic -o libvector.so addvec.c multvec.c

fpic选项指示编译器生成与位置无关的代码。-shared选项指示链接器创建一个共享的目标文件。

linux>gcc -o prog21 main2.c ./libvector.so

这样就创建了一个可执行目标文件prog21，而此文件的形式使得它在运行时可以和libvector.so链接。
基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。
此时，没有任何libvector.so的代码和数据节真的被复制到可执行文件prog21中。
反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对libvector.so中代码和数据的引用。

动态链接器通过执行下面的重定位完成链接任务：

- 重定位libc.so的文本和数据到某个内存段
- 重定位libvector.so的文本和数据到另一个内存段
- 重定位prog21中所有对由libc.so和libvector.so定义的符号的引用。

最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。

## 11. 从应用程序中加载和链接共享库

## 12. 位置无关代码
现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。
使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。
(当然，每个进程仍然会有它自己的读/写数据块。)

可以加载而无需重定位的代码称为位置无关代码(Position-IndependentCode,PIC)。
用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。

### 1. PIC数据引用






























