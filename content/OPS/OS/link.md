---
title: "连接"
date: 2023-11-23T16:49:48+08:00
draft: true
---

# 连接
`链接(linking)`是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。
链接可以执行于编译时(compile time)，也就是在源代码被翻译成机器代码时;
也可以执行于加载时(load time)，也就是在程序被加载器(loader)加载到内存并执行时;
甚至执行于运行时(run time)，也就是由应用程序来执行。
在早期的计算机系统中，链接是手动执行的。
在现代系统中，链接是由叫做链接器(linker)的程序自动执行的。

理解连接作用:

- 理解连椄器将帮助你构造大型程序
- 理解链接器将帮助你避免一些危险的编程错误
- 理解链椄将帮助你理解语言的作用域规则是如何实现的
- 理解链接将帮助你理解其他重要的系统概念
- 理解链接将使你能够利用共享库

## 1. 编译器驱动程序
两个.c文件，main.c和sum.c， 要将sum.c连接到main.c

linux>gcc -Og -o prog main.c sum.c

将main.c翻译成一个ASCII的中间文件main.i:  cpp [other arguments] main.c /tmp/main.i

驱动器运行c编译器（cc1）将.main.i翻译成一个ASCII编码语言文件main.s:  cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s

驱动器运行汇编器(as)将main.s翻译成一个可重定位目标文件main.o:   as [other arguments] -o /tmp/main.o /tmp main.s

经过相同过程生成sum.o

运行链接器程序ld，将main.o和sum.o以及一些必要的系统文件组合起来，创建一个可执行的目标文件prog：
ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o

执行文件：linux>./prog


shell调用操作系统中一个叫做加载器(loader)的两数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。


## 2. 静态连接
像LinuxLD程序这样的静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输人，
生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输人的可重定位目标文件由各种不同
的代码和数据节(section)组成，每一节都是一个连线的宇节序列。

为了构造可执行文件，链接器必须完成两个主要任务:
- 符号解析(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、
一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。符号解析的目的是
将每个符号引用正好和一个符号定义关联起来。
- 重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每
个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使
得它们指向这个内存位置。链接器使用汇编器产生的重定位条目(relocation entry)的详细
指令，不加甄别地执行这样的重定位。

目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则
包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，
并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇
编器已经完成了大部分工作。

## 3. 目标文件
目标文件有三种形式：
- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，
创建一个可执行目标文件。
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

编译器和汇编器生成可重定位目标文件(包括共享目标文件)。
链接器生成可执行目标文件。
从技术上来说，一个目标模块(object module)就是一个字节序列，
而一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块


## 4. 可重定位目标文件
一个典型的ELF可重定位目标文件的格式。ELF头(ELF header)以一个16字节的序列开始，这个序列描述了生成该文件
的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其 中包括ELF头的大小、
目标文件的类型(如可重定 位、可执行或者共享的)、机器类型(如x86-64)、头部表(section header table)的文件
移，以及节部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固 定大小
的条目(entry)。

- .text:已编译程序的机器代码。
- .rodata:只读数据，比如printf语句中的格式串和开关语句的跳转表。
- .data:已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。
- .bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，
它仅仅是一个占位符。目标文件格式区分己初始化和未初始化变量是为了空间效率:在目标文件中，未初始化变量不需要占据
任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。
- .symtab:一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来
编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表(除非程序员特意用
STRIP命令去掉它)。然而，和编译器中的符号表不同，symtab符号表不包含局部变量的条目。
- .rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，
任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标
文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
- .rel.data:被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是
一个全局变量地址或者外部定义西数的地址，都需要被修改。
- .debug:一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源
文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。
- .line:原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表。
- .strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null
结尾的字符串的序列。

## 5. 符号和符号表
每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号:
- 由模块m定义并能被其他模块引用的`全局符号`。全局链接器符号对应于非静态的C两数和全局变量。
- 由其他模块定义并被模块m引用的`全局符号`。这些符号称为`外部符号`，对应于在其他模块中定义的非静态C两数和全局变量。
- 只被模块m定义和引用的`局部符号`。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，
但是不能被其他模块引用。

认识到本地链接器符号和本地程序变量不同是很重要的。.symtab中的符号表不包含对应于本地非静态程序变量的任何符号。
这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。

符号表是由汇编器构造的，使用编译器输出到汇编语言•s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。
```c
typedef struct { 
    int name;   /* String table offset */
    char type:4,    /*Function or data(4 bits) */
         binding:4; /* Local or global (4 bits) */
    char reserved;  /* Unused */
    short section;  /* Section header index */
    long value; /* Section offset or absolute address */ 
    long size; /* Object size in bytes */
} Elf64_Symbol;
```

- name是字符串表中的宇节偏移，指向符号的以null结尾的宇符串名字。
- value是符号的地址。对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。
对于可执行目标文件来说，该值是一个绝对运行时地址。
- size是目标的大小(以字节为单位)。
- type通常要么是数据，要么是函数。
- binding字段表示符号是本地的还是全局的。

## 6. 符号解析
链接器解析符号引用的方法是将每个引用与它输人的可重定位目标文件的符号表中的一个确定的符号定义关联起来。
对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。
编译器只允许每个模块中每个局部符号有一个定义。
静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。

不过，对全局符号的引用解析就辣手得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，
会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在
它的任何输人模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。

全局符号的符号解析很辣手，还因为多个目标文件可能会定义相同名字的全局符号。
在这种情况中，链接器必领要么标志一个错误，要么以某种方法选出一个定义并拋弃其他定义。
Linux系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能给不警觉的程序员带来一些麻烦

### 1. 链接器如何解析多重定义的全局符号
链接器的输人是一组可重定位目标模块。每个模块定义一组符号，有些是局部的(只对定义该符号的模块可见)，
有些是全局的(对其他模块也可见)。

在编译时，编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱(weak)，而汇编器把这个信息隐含地
编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名:
- 规则1：不允许有多个同名的强符号
- 规则2：如果有一个强符号和多个若符号同名，那么选择强符号
- 规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个

规则2和3的应用会导致一些错误，比如定义了两个不同类型同名的全局变量，只会给出警告。

### 2. 与静态库连接
实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为`静态库(static library)`，
它可以用做链接器的输人。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，
有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后级.a标识。

举例：
有两个.c文件addvec.c 和 multvec.c
1. 使用AR工具创建函数的一个静态库
linux>gcc -c addvec.c multvec.c
linux>ar rcs libvector.a addvec.o multvec.o
2. （main2.c 调用addvec库例程，main2.c包含vector.h）编译和连接输入文件main.o和libvector.a
linux>gcc -c main2.c
linux>gcc -static -o prog2c main.0 ./libvector.a
或者等价使用
linux>gcc -c main2.c
linux>gcc -static -o -prog2c main2.o -L -lvector

当链接器运行时，它判定main2.0引用了addvec.o定义的addvec符号，所以复制addvec.o到可执行文件。
因为程序不引用任何由multvec.o定义的符号，所以链接器就不会复制这个模块到可执行文件。
链接器还会复libc.a中的printf.o模块，以及许多C运行时系统中的其他模块。

### 3. 链接器如何使用静态库来解析引用
虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于Linux链接器使用它们解析外部引用的方式。
在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。
(驱动程序自动将命令行中所有的.c文件翻译为.o文件。)在这次扫描中，链接器维护一个可重定位目标文件的
集合E(这个集合中的文件会被合并起来形成可执行文件)，一个未解析的符号(即引用了但是尚未定义的符号)集合U，
以及一个在前面输人文件中已定义的符号集合D。初始时，E、U和D均为空。


- 对于命令行上的每个输人文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，
那么链接器把f添加到E，修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。
- 如果f是一个存档文件，那么链接器就尝试匹配U中木解析的符号和由存档文件成员定义的符号。
如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器
修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到
U和D都不再发生变化。此时，任何不包含在E中的成员目标文件都简单地被丟弃，而链接器将继续处理下一个输人文件。
- 如果当链接器完成对命令行上输人文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。
否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。

关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的(也就是说没有成员引用另一个
成员定义的符号)， 那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库不是相互独立的，
那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在
对s的引用之后的。比如，假设foo.c调用libx.a和libz.a中的函数，而这两个库又调用liby.a中的函数。
那么，在命令行中libx.a和libz.a必须处在liby.a之前:

linux>gcc foo.c libx.a libz.a liby.a

如果需要满足依赖需求，可以在命令行上重复库。比如，假设foo.c调用libx.a中的函数，
该库又调用liby.a中的函数，而liby.a又调用libx.a中的函数。那么libx.a必须在命令行上重复出现:

linux>gcc foo.c libx.a liby.a libx.a

另一种方法是，我们可以将1ibx.a和1iby•a合并成一个单独的存档文件

## 7. 重定位
一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义(即它的一个输入目标
模块中的一个符号表条目)关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。
现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成:
- 重定位节和符号定义。
在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节
被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给
新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的
每条指令和全局变量都有唯一的运行时内存地址了
- 重定位节中的符号引用
在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。
要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目(relocation entry)的数据结构，
我们接下来将会描述这种数据结构。

### 1. 重定位条目
当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道
这个模块引用的任何外部定义函数数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置
未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何
修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在。rel.data中。

```c
typedef struct {
    long offset; /*Offset of the reference to relocate */ 
    long type:32, /*Relocation type */
         symbol:32; /*Symbol table index */
    long addend; /* Constant part of relocation expression */
} Elf64_Rela;
```
- offset是需要被修改的引用的节偏移。
- symbol标识被修改引用应该指向的符号。
- type告知链接器如何修改新的引用。
- addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

ELF定义了32种不同的重定位类型，有些相当隐秘。我们只关心其中两种最基本的重定位类型:
- Rx86_64_PC32。重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距
程序计数器(PC)的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，
它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址(如call指令
的目标)，PC值通常是下一条指令在内存中的地址。
- Rx86_64_32。重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用
在指令中编码的32位值作为有效地址，不需要进一步修改。

这两种重定位类型支持x86-64小型代码模型(small code model)，该模型假设可执行
目标文件中的代码和数据的,总体大小小于2GB，因此在运行时可以用32位PC相对地址来
访问。GCC默认使用小型代码模型。大于2GB的程序可以用-mcmodel=medium(中型代码
模型)和-mcmodel-large(大型代码模型)标志来编译，不过在此我们不讨论这些模型。

### 2. 重定位符号引用
```
foreach section s { // 每个节s
    foreach relocation entry r {    // 每个重定位条目r
        refptr = s + r.offset;  /* ptr to reference to be relocated */ // 计算重定位的4字节引用的数组s中的地址
        /* Relocate a PC-relative reference */  // PC相对寻址
        if (r.type == R_X86_64_PC32) {
            refaddr = ADDR(s) + r.offset;   /* ref's run-time address */
            *refptr = (unsigned)(ADDR(r.symbol) + r.addend - refaddr);
        }
        /* Relocate an absolute reference */    // 绝对寻址
        if (r.type == R_X86_64_32) {
            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);
        }
    }
}
```

举例（汇编）：
```
0000000000000000<main>:
    0:  48 83 ec 08             sub $0x8, %rsp
    4:  be 02 00 00 00          mov $0x2, %esi  
    9:  bf 00 00 00 00          mov $0x0, %edi  // %edi = &array
                        a: R_X86_64_32 array
    e:  e8 00 00 00 00          callq 13, <main+0x13>   // sum()
                        f: R_X86_64_PC_32 sum-0x4
    13: 48 83 c4                add $0x8, %rsp
    17: c3                      retq
```

1. 重定位PC相对引用
函数main调用sum函数，sum西数是在模块sum.o中定义的。call指令开始于节偏移Oxe的地方，
包括1字节的操作码0xe8，后面跟着的是对目标sum的32位PC相对引用的占位符。

相应的重定位条目r由4个字符组成：
- r.offset = 0xf 
- r.symbol = sum
- r.type = R_X86_64_PC_32
- r.addend = -4

这些字段告诉链接器修改开始于偏移量Oxf处的32位PC相对引用，这样在运行时它会指向sum例程 。
现在，假设链接器已经确定

ADDR(s) = ADDR(.text) = 0x4004d0 和 ADDR(s.symbol) = ADDR(sum) = 0x4004e8

计算出引用的运行时地址：

refaddr = ADDE(s) + r.offset = 0x4004d0 + 0xf = 0x4004df

更新该引用，使得它在运行时指向sum程序：

*refptr = (unsigned)(ADDR(r.symbol)+r.addend-refaddr) = (unsigned)(0x4004e8 + (-4) - 0x4004df) = (unsigned)(0x5)

在得到的可执行目标文件中，call指令有如下的重定位形式：

3004de: e8 05 00 00 00  callq 4004e8<sum> // sum()

在运行时，call指令将存放在地址0x4004de处。当CPU执行call指令时，PC的值为0x4004e3，
即紧随在call指令之后的指令的地址。为了执行这条指令，CPU执行以下的步骤:
- 将PC压入栈中
- PC <- PC + 0x5 = 0x4004e3 + 0x5 = 0x4004e8
  
因此，要执行的下一条指令就是sum例程的第一条指令，这当然就是我们想要的

### 2. 重定位绝对引用
重定位绝对引用相当简单。mov指令将array的地址(一个32位立即数值)复制到奇存器%edi中。
mov指令开始于节偏移量0x9的位置，包括1宇节操作码oxbf，后面跟着对array的32位绝对引用的占位符。
对应的占位符条目工包括4个字段:
- r.offset = 0xa
- r.symbol = array
- r.type = R_X86_64_32
- r.addend = 0

这些字段告诉链接器要修改从偏移量0xa开始的绝对引用，这样在运行时它将会指向array的第一个字节。
现在，假设链接器己经确定

ADDR(r.symbol) = ADDR(array) = 0x601018

链接器修改引用：

*refptr = (unsigned)(ADDR(r.symbol) + r.addend)=(unsigned)(0x601018 + 0) = (unsigned)(0x601018)

得到可执行目标文件中，引用有下面的重定位：

4004d9: bf 18 10 60 00  mov $0x606018, %edi

## 8. 可执行文件
二进制文件：

| 名称                                              | 在哪              |
|-------------------------------------------------|-----------------|
| ELF头，段头部表（将连续的文件节映射到运行时内存段），.init,.text,.rodata | 只读内存段（代码段）      |
| .data,.bss                                      | 读/写内存段（数据段）     |
| .symtab,.debug,.line.strtab,节头部表（描述目标文件的节）      | 不加载到内存的符号表和调试信息 |

执行目标文件的格式类似于可重定位目标文件的格式。ELF头描述文件的总体格式。它还包括程序
的入口点(entry point)，也就是当程序运行时要执行的第一条指令的地址。.text、.rodata
和.data节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时
内存地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可
执行文件是完全链接的(已被重定位)，所以它不再需要.rel节。

ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射，到连续的内存段。
程序头部表(program header table)描述了这种映射关系。可执行文件prog的程序头部表，是由OBJDUMP显示的。

// code/link/prog-exe.d
```
// read-only code segment
1. LOAD off 0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21
2.      filesz 0x000000000000069c memsz 0x000000000000069c flags r-x
// Read/Write data segment
3. LOAD off 0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21
4.    filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw-
```
// code/link/prog.exe.d

- off:目标内存中的偏移
- vaddr/paddr: 内存地址
- align: 对齐要求
- filesz: 目标文件中段大小
- memsz：内存中的段大小
- flags: 运行时访问权限

第一行和第2行告诉我们第一个段(代码段)有读/执行访问权限，开始于内存地址0x400000处，总共的内存大小
是0x69c字节，并且被初始化为可执行目标文件的头0x69c个字节，其中包括ELF头、程序头部表以及
.init、.text和.rodata节。

第3行和第4行告诉我们第二个段(数据段)有读/写访问权限，开始于内存地址0x600df8处，
总的内存大小为0x230字节，并用从目标文件中偏移Oxdf8处开始的.data节中的ox228个
字节初始化。该段中剩下的8个字节对应于运行时将被初始化为0的.bss数据。

对于任何段s，链接器必须选择一个起始地址vaddr，使得

vaddr mod align = off mod align

这里，off是目标文件中段的第一个节的偏移量，align是程序头部中指定的对齐(21=0x200000)。

例如：vaddr mod align = 0x600df8 mod 0x200000 = 0xdf8  以及 off mod align = 0xdf8 mod 0x200000 = 0xdf8

这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中。
原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大小为2的幂的字节片。

## 9. 加载可执行目标文件

## 10. 动态连接共享库
共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，
在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。
这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器(dynamic linker)
的程序来执行的。共享库也称为共享目标(shared object)，在Linux系统中通常用.so后缀来表示。
微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)。

调用编译器驱动程序：

linux>gcc -shared -fpic -o libvector.so addvec.c multvec.c

fpic选项指示编译器生成与位置无关的代码。-shared选项指示链接器创建一个共享的目标文件。

linux>gcc -o prog21 main2.c ./libvector.so

这样就创建了一个可执行目标文件prog21，而此文件的形式使得它在运行时可以和libvector.so链接。
基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。
此时，没有任何libvector.so的代码和数据节真的被复制到可执行文件prog21中。
反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对libvector.so中代码和数据的引用。

动态链接器通过执行下面的重定位完成链接任务：

- 重定位libc.so的文本和数据到某个内存段
- 重定位libvector.so的文本和数据到另一个内存段
- 重定位prog21中所有对由libc.so和libvector.so定义的符号的引用。

最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。

## 11. 从应用程序中加载和链接共享库

## 12. 位置无关代码
现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。
使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。
(当然，每个进程仍然会有它自己的读/写数据块。)

可以加载而无需重定位的代码称为位置无关代码(Position-IndependentCode,PIC)。
用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。

### 1. PIC数据引用
编译器通过运用以下这个有趣的事实来生成对全局变量的PIC引用:无论我们在内存中的何处加载一个目标模块
(包括共享目标模块)，数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之
间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。

想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表
(Global Offset Table,GOT)。在GOT中，每个被这个目标模块引用的全局数据目标(过程或全局变量)都有一
个8字节条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，
使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的GOT。

### 2. PIC函数调用
假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义亡的共享模块在
运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再
解析它。不过，这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，GNU编译系统使用了一种很有趣
的技术来解决这个问题，称为`延迟绑定(lazy binding)`，将过程地址的绑定推迟到第一次调用该过程时。

使用延迟绑定的动机是对于一个像libc.so这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用
其中很少的一部分。把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个
其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间
按的内存引用。

延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是:GOT和过程链接表
(Procedure Linkage Table，PLT)。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己
的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。

- 过程链接表(PLT)。PLT是一个数组，其中每个条目是16字节代码。PLT[O1]是一个特殊条目，它跳转到动态链接器
中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。PIT[1]调用系统
启动函数(__libc_start_main)，它初始化执行环境，调用main函数并处理其返回值。从PIT[2]开始的条目调用
用户代码调用的函数。
- 全局偏移量表(GOT)。正如我们看到的，GOT是一个数组，其中每个条目是8宇节地址。和PLT联合使用时，GOT[O]
和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。
其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLI条目。
例如，GOT[4]和PLT[2]对应于addvec。初始时，每个GOT条目都指向对应PLT条目的第二条指令。


例子a
```
// 数据段  全局偏移量表（GOT）
GOT[0]: addr of .dynamic
GOT[1]: addr of reloc entries
GOT[2]: addr of dynamic linker
GOT[3]: 0x4005b6 # sync startup
GOT[4]: 0x4005b6 # addvec()
GOP[6]: 0x4005b6 # printf()

// 代码段
callq 0x4005c0 # call addvec()
// 过程链接表(PLT)
# PLT[0]: call dynamic linker
4005a0: pushq *GOT[1]
4005a6: jmpq *GOP[2]
...
#PLT[2]: call addvec()
4005c0: jmpq *GOP[4]
4005c6: pushq $0x1
4005cb: jmpq 4005a0
```

例子b
```
// 数据段  全局偏移量表（GOT）
// 数据段  全局偏移量表（GOT）
GOT[0]: addr of .dynamic
GOT[1]: addr of reloc entries
GOT[2]: addr of dynamic linker
GOT[3]: 0x4005b6 # sync startup
GOT[4]: &addvec()
GOP[6]: 0x4005b6 # printf()

// 代码段
callq 0x4005c0 # call addvec()
// 过程链接表(PLT)
# PLT[0]: call dynamic linker
4005a0: pushq *GOT[1]
4005a6: jmpq *GOP[2]
...
#PLT[2]: call addvec()
4005c0: jmpq *GOP[4]
4005c6: pushq $0x1
4005cb: jmpq 4005a0
```

例子a展示了GOP和PLT如何协同工作，在第一次addvec被调用时，延迟解析它的运行地址：
- 不直接调用addvec，程序调用进人PIT[2〕，这是addvec的PLT条目
- 第一条PLT指令通过GOT[4]进行间接跳转。因为每个GOT条目初始时都指向它对应的GLT条日的第二条指令，
这个间接跳转只是简单地把控制传送回PIT[2]中的下一条指令。
- 在把addvec的ID(0x1)压人栈中之后，PLT[2]跳转到PLT[0]。
- PII[O]通过GOT[1]间接地把动态链接器的一个参数压入栈中，然后通过GOT[2]间接跳转进动态链接器中。
动态链接器使用两个栈条目来确定addvec的运行时位置，用这个地址重写GOT[4]，再把控制传递给addvec。

例子b给出的是后续在调用addvec时的控制流：
- 和前面一样，控制传递到PLT[2]
- 不过这次通过GOT[4]的间接跳转会将控制直接转移到addvec

## 13. 库打桩机制
Linux链接器支持一个很强大的技术，称为`库打桩(library interpositioning)``，它允许你截获对共享库函数
的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入
和输出值，或者甚至把它替换成一个完全不同的实现。

下面是它的基本思想:给定一个需要打桩的`目标函数`，创建一个`包装函数`，它的原型与目标函数完全一样。
使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻
辑，然后调用目标函数，再将目标函数的返回值传递给调用者。



### 1. 编译时打桩
int.c
```c
#include<stdio.h>
#include<malloc.h>

int main()
{
    int *p = malloc(32);
    free(p);
    return (0);
}
```

malloc.h
```c
#define malloc(size) mymalloc(size)
#define free(ptr) myfree(ptr)

void *mymalloc(size_t size);
void myfree(void *ptr)
```

malloc.c
```c
#ifdef COMPILETIME
#include<stdio.h>
#include<malloc.h>

/* malloc wrapper function*/
void *mymalloc(size_t size)
{
    void *ptr = malloc(size);
    printf("malloc(%d)=%p\n", (int)size, ptr);
    return ptr;
}
/* free wrapper function*/
void myfree(void *ptr)
{
    free(ptr);
    printf("free(%p)\n", ptr);
}

#endif
```

mymal1oc.c中的包装函数调用目标函数，打印追踪记录，并返回。本地的malloc.h头文件指示预处理器
用对相应包装函数的调用替换掉对目标函数的调用。像下面这样编译和链接这个程序:

linux>gcc -DCOMPILETIME -c mymalloc.c

linux>gcc -I. -o intc int.c mymalloc.o

由于有-I.参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，先在当前目录中查找malloc.h。
注意，mymalloc.c中的包装函数是使用标准malloc.h头文件编译的.

运行这个程序会得到如下的追踪信息:

linux>./intc

malloc(32)=0x9ee010

free(0x9ee010)

### 2. 链接时打桩
Linux静态链接器支持用--wrap_f标志进行链接时打桩。这个标志告诉链接器，把对符号f的引用解析成__wrap_f
(前级是两个下划线)，还要把对符号__real_f(前级是两个下划线)的引用解析为f。图7-21给出我们示例程序的包装函数。a

malloc.c
```c
#ifdef LINKTIME
#include<stdio.h>

void *__real_malloc(size_t size);
void __real_free(void *ptr)

/* malloc wrapper function*/
void *mymalloc(size_t size)
{
    void *ptr = __real_malloc(size);    /*call libc malloc*/
    printf("malloc(%d)=%p\n", (int)size, ptr);
    return ptr;
}
/* free wrapper function*/
void myfree(void *ptr)
{
    __real_free(ptr);   /*call libc free*/
    printf("free(%p)\n", ptr);
}

#endif
```
用上述方法把这些源文件编译成可重定位目标文件:

linux>gcc -DLINKTIME -c mymalloc.c

linux>gcc -c int.c

然后把目标文件链接成可执行文件：

linux>gcc -Wl,--warp,malloc -Wl,--warp,free -o intl int.o mymalloc.o

-WI,option标志把option传递给链接器。option中的每个逗号都要替换为一个空格，所以-Wl,--warp,malloc
就把--warp malloc传递给链接器以类似的方式传递给-Wl,--warp,free。

- -Wl：这个选项告诉 gcc 将后面的选项传递给链接器。gcc 本身既是编译器也是链接器的前端，
而 -Wl 选项用于指定链接器（ld）的选项。
- --wrap,malloc 和 --wrap,free：这些是链接器的特定选项。--wrap 选项用于替换库调用。
例如，使用 --wrap,malloc 会导致程序中对 malloc 函数的所有调用都被替换为对 __wrap_malloc
的调用。同样，--wrap,free 会替换所有的 free 调用为 __wrap_free。这通常用于调试、监控或替换标准库函数。

### 3. 运行时打桩
编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。
不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个很厉害的机制
基于动态链按器的LD_PRELOAD环境变量。 

如果LD_PRELOAD环境变量被设置为一个共享库路径名的列表(以空格或分号分隔)，那么当你
加载和执行一个程序，需要解析未定义的引用时， 动态链接器(LD-Linux.SO)会先搜索LD_PRELOAD库，
然后才搜素任何其他的库。有了这个机制，当你加载和执行任意可执行文件时，可以对任何共享库中的任何
函数打桩，包括libc.so。


malloc.c
```c
#ifdef RUNTIME
#deine _GUN_SOURCE
#include<stdio.h>
#include<stdlib.h>
#include<dlfcn.h>

/* malloc wrapper function*/
void *mymalloc(size_t size)
{
    void *(mallocp)(size_t size);
    char *error;

    mallocp = dlsym(RTLD_NEXT, "malloc");/* Get address of libs malloc */
    if ((error = dlerror()) != NULL)
    {
        fpits(error, stderr);
        exit(1);
    }

    char *ptr = mallocp(size);    /*call libc malloc*/
    printf("malloc(%d)=%p\n", (int)size, ptr);
    return ptr;
}
/* free wrapper function*/
void myfree(void *ptr)
{
    void (*freep)(void*) = NULL;
    char *error;
    if (!ptr)
        return;
    freep = dlsym(RTLD_NEXT, "free"); /* Get address of libc free */
    if ((error = dlerror()) != NULL )
    {
        fputs(error, stderr);
        exit(1);
    }
    freep(ptr);   /*call libc free*/
    printf("free(%p)\n", ptr);
}

#endif
```
构建包含这些包装函数的共享库的方法：

linux>gcc -DRUNTIME - shared -fpic -o mymalloc.so mymalloc.c -ldl

如何编译主程序：

linux>gcc -o intr int.c

从bash_shell运行程序:

linux>LD_PRELOAD="./mymalloc.so" ./intr

malloc(32) = 0x1bf7010

free(0x1bf7010)

## 14. 处理目标文件的工具
在Linux系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，
GNU binutils包尤其有帮助，而且可以运行在每个Linux平台上。

- AR:创建静态库，插人、删除、列出和提取成员。
- STRINGS:列出一个目标文件中所有可打印的字符串。
- STRIP:从目标文件中删除符号表信息。
- NM:列出一个目标文件的符号表中定义的符号。
- SIZE:列出目标文件中节的名字和大小。
- READELF:显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能。
- OBJDUMP:所有二进制工具之母。能够显示一个目标标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令。
Linux系统为操作共享库还提供了LDD程序:
- LDD:列出一个可执行文件在运行时所需要的共享库。

## 15. 小结
链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。
链接器处理称为目标文件的二进制文件，它有3种不同的形式:可重定位的、可执行的和共享的。
可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。
共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和
开始执行时，或者根据需要在程序调用dlopen库的两数时。

链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，
而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。

静态链接器是由像GCC这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。
至个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引人微妙的错误。

多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。
许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误的来源。

加载器将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，
这样的文件中有对定义在共享库中的例程和数据的末解析的引用。在加载时，加载器将部分链接的可执行
文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。

被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。
为了加载、链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。



































