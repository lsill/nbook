---
title: "异常控制流"
date: 2023-11-27T16:56:48+08:00
draft: true
---
# 异常控制流

现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为
异常控制流(ExceptionalControlFlow，ECF)。

理解ECF作用：
- 理解ECF将帮助你理解重要的系统概念。ECF是操作系统用来实现I/O、进程和
虛拟内存的基本机制。在能够真正理解这些重要概念之前，你必须理解ECF。
- 理解ECF将帮助你理解应用程序是如何与操作系统交互的。应用程序通过使用一
个叫做陷阱(trap)或者系统调用(systemc all)的ECF形式，向操作系统请求服务。
比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通
过应用程序调用系统调用来实现的。理解基本的系统调用机制将帮助你理解这
些服务是如何提供给应用的。
- 理解ECF将帮助你编写有趣的新应用程序。操作系统为应用程序提供了强大的
ECF机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，
以及检测和响应这些事件。如果理解了这些ECF机制，那么你就能用它们来编写
诸如Unix shell和Web服务器之类的有趣程序了。
- 理解ECF将帮助你理解并发。ECF是计算机系统中实现并发的基本机制。在运行中的
并发的例子有:中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，以
及中断应用程序执行的信号处理程序。理解ECF是理解并发的第一步。
- 理解ECF将帮助你理解软件异常如何工作。像C++和Java这样的语言通过try、catch以及throw
语句来提供软件异常机制。软件异常允许程序进行非本地跳转(即违反通常的调用/返回栈规则的跳转)
来响应错误情况。非本地跳转是一种应用层ECF，在C中是通过setjmp和longjmp函数提供的。
理解这些低级函数将帮助你理解高级软件异常如何得以实现。

## 1. 异常
`异常`就是控制流中的突变，用来响应处理器状态中的某些变化

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表(exception table)的跳转表，
进行一个间接过程调用(异常)，到一个专门设计用来处理这类事件的操作系统子程
序(`异常处理程序(exception handler)`)。当异常处理程序完成处理后，根据引起异常的事件的类型，
会发生以下3种情况中的一种:

1)处理程序将控制返回给当前指令Jcur，即当事件发生时正在执行的指令。

2)处理程序将控制返回给Ineat，如果没有发生异常將会执行的下一条指令。

3)处理程序终止被中断的程序。

### 1. 异常处理
异常表的起始地址放在一个叫做`异常值基址寄存器(exception table base register)`的特殊
CPU寄存器里。

异常类似于过程调用，但是有一些重要的不同之处：
- 过程调用时，在跳转到处理程序之前，处理器将返回地址压人栈中。
然而，根据异常的类型，返回地址要么是当前指令(当事件发生时正在
执行的指令)，要么是下一条指令(如果事件不发生，将会在当前指令后执行的指令)。
- 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被
中断的程序会需要这些状态。比如，x86-64系统会将包含当前条件码的EFLAGS奇存
器和其他内容压入栈中。
- 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。
- 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。

一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，
它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到
处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用户模式，然后将
控制返回给被中断的程序。

## 2. 异常的别类
异常可以分为四类:中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)。表对这些类别的属性做了小结。

| 类别 | 原因         | 异步/同步 | 返回行为       |
|----|------------|-------|------------|
| 中断 | 来自I/O设备的信号 | 异步    | 总是返回到下一条指令 |
| 陷阱 | 有意的异常      | 同步    | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误   | 同步    | 可能返回到当前指令  |
| 终止 | 不可恢复的错误    | 同步    | 不会返回       |

异常的类別。异步异常是由处理器外部的I/O设备中的事件产生的。同步异常是执行一条指令的直接产物

### 1. 中断
中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的
，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序(interrupt handler)。

在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，
然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令(也即如果
没有发生中断，在控制流中会在当前指令之后的那条指令)。结果是程序继线执行，就好像没
有发生过中断一样。

### 2. 陷阱和系统调用
陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到
下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。

从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。
普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能
访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指
令，并访问定义在内核中的栈。

### 3. 故障
故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给
故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从
而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。

一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中
，因此必领从磁盘中取出时，就会发生故障。

### 4. 终止
终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的
奇偶错误。终止处理程序从不将控制返回给应用程序。

## 3. Linux/x86-64系统中的异常
x86-64系统定义的一些异常。有高达256种不同的异常类型[50]。0~31的号码对应的是由
Intel架构师定义的异常，因此对任何x86-64系统都是一样的。32~255的号码对应的是操
作系统定义的中断和陷阱。

| 异常号    | 描述        | 异常类别  |
|--------|-----------|-------|
| 0      | 除法错误      | 故障    |
| 13     | 一般保护故障    | 故障    |
| 14     | 缺页        | 故障    |
| 18     | 机器检查      | 终止    |
| 32~255 | 操作系统定义的异常 | 中断或陷阱 |

### 1. Linux/x86-64 故障和终止
- 除法错误。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数米说太大了
的时候，就会发生除法错误(异常0)。Unix不会试图从除法错误中恢复，而是选择终止程序。
Linuxshell通常会把除法错误报告为“浮点异常(Floating exception)”
- 一般保护故障。许多原因都会导致不为人知的一般保护故障(异常13)，通常是因为一个程
序引用了一个未定义的虛拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝
试恢复这类故障。Linux shell通常会把这种一般保护故障报告为“段故障(Segmentation fault)".
- 缺页(异常14)是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一
个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。
- 机器检查。机器检查(异常18)是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查
处理程序从不返回控制给应用程序。

### 2. Linux/86-64系统调用
Linux提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文件、写文件或是创建一个新进程。

C程序用syscall函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数
系统调用，标准C库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统
调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。在本书中，我们将系统调用和与
它们相关联的包装函数都称为系统级函数，这两个术语可以互换地使用。

在x86-64系统上，系统调用是通过一条称为syscall的陷阱指令来提供的。研究程序能够如何使用
这条指令来直接调用Linux系统调用是很有趣的。所有到Linux系统调用的参数都是通过通用寄存器
而不是栈传递的。按照惯例，奇存器%rax包含系统调用号，寄存器号%rdi、%rsi、%rdx、%r10、
%r8和%e9包含最多6个参数。第一个参数在%rdi中，第二个在%rsi中，以此类推。从系统调用返回
时，寄存器%rcx和%r11都会被破坏，%rax包含返回值。一4095到-1之间的负数返回值表明发生了
错误，对应于负的errno.

Linux x86-64系统中常用的系统调用示例。

| 编号 | 名字     | 描述         |
|----|--------|------------|
| 0  | read   | 读文件        |
| 1  | write  | 写文件        |
| 2  | open   | 打开文件       |
| 3  | close  | 关闭文件       |
| 4  | stat   | 获得文件信息     |
| 9  | mmap   | 将内存页映射到文件  |
| 12 | brk    | 重置堆顶       |
| 32 | dup2   | 复制文件描述符    |
| 33 | pause  | 挂起进程知道信号到达 |
| 37 | alarm  | 调度告警信号的传送  |
| 39 | getpid | 获得进程ID     |
| 57 | fork   | 创建进程       |
| 59 | execve | 执行一个程序     |
| 60 | _exit  | 终止进程       |
| 61 | wait4  | 等待一个进程终止   |
| 62 | kill   | 发送信号到一个进程  |

举例：
```c
int main()
{
    write(1, "hello, world\n",13);
    _exit(0);
}
```
write函数的第一个参数将输出发送到stdout。第二个参数是要写的字节序列，而第三个参数是要写的字节数

```汇编
1   .section .data
2   string:
3       .ascii "hello, world\n"
4   string_end:
5       equ len, string_end - string
6   .section .text
7   .global main
8   main:
        // First, call write(1, "hello, world\n", 13)
9       movq $1, %rax   // write is system call 1
10      movq $1, %rdi   // Arg1: stdout has descriptor 1
11      movq $string, %rsi  // Arg2: hello world string
12      movq %len, %rdx     // Arg3: string length
13      syscall     // make the system call
        // Next call _exit(0)
14      movq $60, %rax  // _exit is system call 60
15      movq $0, %rdi   // Arg1: exit status is 0
16      syscall     // make the system call
```

## 2. 进程
进程的经典定义就是一个`执行中程序的实例`。系统中的每个程序都运行在某个进程的
`上下文(context)`中。上下文是由程序正确运行所需的状态组成的。这个状态包括存
放在内存中的程序的代码和数据，它的栈、通用目的的寄存器的内容、程序计数器、
环境变量以及打开文件描述符的集合。

每次用户通过向shell输人一个可执行目标文件的名字，运行程序时，shell就会创建
一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能
够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。

进程提供给应用程序的关键抽象：
- 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。
- 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。

### 1. 逻辑控制流
即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像
它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数
器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在
运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做`逻辑控制流`，或者简称`逻辑流`。

每个进程执行它的流的一部分，然后被抢占(preerpted)(智时挂起)，然后轮到其他进程。
对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。唯
一的反面例证是，如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执
行之间，CPU好像会周期性地停顿。然而，每次处理器停顿，它随后会继续执行我们的程序，
并不改变程序内存位置或寄存器的内容。

### 2. 并发流
一个逻辑流的执行在时间上与另一个流重叠，称为`并发流(concurrent flow)`，这两个流被
称为`并发地运行`。更准确地说，流X和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，
或者Y在X开始之后和X结東之前开始。

多个流并发地执行的一般现象被称为`并发(concurrency)`。一个进程和其他进程轮流运行的概念
称为`多任务(multitasking)`。一个进程执行它的控制流的一部分的每一时间段叫做`时间片(time slice)`。
因此，多任务也叫做`时间分片(time slicing)`。

注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么
它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现确认并行流是很有
帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那
么我们称它们为`并行流(parallel flow)`，它们并行地运行(runing in parallel)，且
并行地执行(parallel execution)。

### 3. 私有地址空间
进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台n位地址的机器上，
地址空间是2^n个可能地址的集合，0，1，....，2^n-1。进程为每个程序提供它自己的私有
地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者
写的，从这个意义上说，这个地址空间是私有的。

尽管和每个私有地址空问相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。
![进程地址空间](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.jpg)

### 4. 用户模式和内核模式
为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，
限制一个应用可以执行的指令以及它可以访问的地址空间范围。

处理器通常是用 某个控制寄存器中的一个`模式位(mode bit)`来提供这种功
能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在
`内核模式`中(有时叫做`超级用户模式`)。一个运行在内核模式的进程可以执
行指令集中的任何指令，并且可以访问系统中的任何内存位置。

没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特
权指令(privileged instruction)，比如停止处理器、改变模式位，或者发
起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码
和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必领通过系统
调用接口间接地访问内核代码和数据。

运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式
的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，
控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行
在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用
户模式。

Linux提供了一种聪明的机制，叫做/proc文件系统，它允许用户模式进程访问内
核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程
序可以读的文本文件的层次结构。比如，你可以使用/proc文件系统找出一般的系
统属性，比如CPU类型(/proc/cpuinfo)，或者某个特殊的进程使用的内存段
(/proc/<process-id>/maps)。2.6版本的Linux内核引人/sys文件系统，它
输出关于系统总线和设备的额外的低层信息。

## 5. 上下文切换
操作系统内核使用一种称为`上下文切换(context switch)`的较高层形式的异常控制流
来实现多任务。上下文切换机制是建立在那些较低层异常机制之上的。

内核为每个进程维持一个`上下文(context)`。上下文就是内核重新启动一个被抢占的进程
所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点奇存器、程序计数
器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的`页表`、包含有关
当前进程信息的`进程表`，以及包含进程己打开文件的信息的`文件表`。

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。
这种决策就叫做`调度(scheduling)`，是由内核中称为`调度器(scheduler)`的代码处理
的。当内核选择一个新的进程运行时，我们说内核`调度了`这个进程。在内核调度了一个新的
进程运行后，它就抢占当前进程，并使用一种称为`上下文切换`的机制来将控制较移到新的进
程，`上下文切换`
1. 保存当前进程的上下文，
2. 恢复某个先前被抢占的进程被保存的上下文，
3. 将控制传递给这个新恢复的进程。

当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件
发生而阻塞，那么内核可以让当前进程休眼，切换到另一个进程。比如，如果一个read系统
调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从
磁盘到达。另一个示例是sleep系统调用，它显式地请求让调用进程休眼。一般而言，即使
系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。

中断也可能引发上下文切換。比如，所有的系统都有某种产生周期性定时器中断的机制，通
常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够
长的时问，并切换到一个新的进程。

## 3. 系统调用错误处理
当Unix系统级西数遇到错误时，它们通常会返回一1，并设置全局整数变量errno来表示什么出错了。

如何检查错误
```c
    if ((pid = fork()) < 0)
    {
        fprintf(stderr, "fork error:%s\n", strerror(errno));
        exit(0);
    }
// strerror两数返回一个文本串，描述了和某个errno值相关联的错误。
// 通过定义下面的错误报告函数，能够在某种程度上简化这个代码:
void unix_error(char *msg)  /* Unix-style error */ 
{
    fprintf(stderr, "%s: %s\n", msg,strerror(errno));
    exit(0);
}
    if ((pid = fork()) < 0)
        unix_error("fork error");
// 进一步简化
pid_t Fork(void)
{
    pid_t pid;
    if ((pid = fork()) < 0)
        unix_error("fork error");
    return pid;
}

pid = Fork();
```

## 4. 进程控制
### 1. 获取进程ID
每个进程都有一个唯一的正数(非零)进程`ID(PID)`。getpid两数返回调用进程的PID。
getppid两数返回它的父进程的PID(创建调用进程的进程)。

### 2. 创建和终止进程
程总是处于下面三种状态之一:
- 运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。
- 停业。进程的执行被桂起(suspended)，且不会被调度。当收到SIGSTOP、SIGT-STP、
SIGTTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信号，
在这个时刻，进程再次开始运行。
- 终止。进程永远地停止了。进程会因为三种原因终止:1)收到一个信号，该信号的默认行
为是终止进程，2)从主程序返回，3)调用exit函数。

exit函数以status退出状态来终止进程(另一种设置退出状态的方法是从主程序中返回一个整数值)。


父进程通过调用fork两数创建一个新的运行的子进程。

新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虛拟地址空间相同的
(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程
任何打开文件描述符相同的副本，这就意味者当父进程调用fork时，子进程可以读写父进程中
打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID

fork函数是有趣的(也常常令人迷惑)，因为它只被调用一次，却会返回两次:一次是在调用进程
(父进程)中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID。在子进程中，
fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辦程序是在父进程
还是在子进程中执行。

父进程和子进程关系：
- 调用一次，返回两次。fork函数被父进程调用一次，但是却返回两次，一次是返回到父进程，
一次是返回到新创建的子进程。对于只创建一个子进程的程序来说，这还是相当简单直接的。
但是具有多个fork实例的程序可能就会令人迷惑，需要仔细地推敲了。
- 并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑
控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的printf语句，然后是子进
程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令
的交替执行做任何假设。
- 相同但是独立的地址空问。如果能够在fork函数在父进程和子进程中返回后立即哲停这两个进程
，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同
的堆、相同的全局变量值，以及相同的代码。然而，因为父进程和子进程是独立的进程，它们都有自
己的私有地址空间。
- 共享文件。原因是子进程继承了父进程所有的打开文件。当父进程调用Fork时，stdout文件是打
开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。

### 3. 回收子进程
当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种
已终止的状态中，直到被它的父进程`回收(reaped)`。当父进程回收已终止的子进程时，内核
将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。
一个终止了但还未被回收的进程称为`僵死进程(zombie)`。

如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。init进程的PID为1，
是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵
死子进程就终止了，那么内核会安排init进程去回收它们。不过，长时间运行的程序，比如
shell或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消
耗系统的内存资源。

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options)
```

一个进程可以通过调用waitpid两数来等待它的子进程终止或者停止。waitpid函数有点复杂。
默认情况下(当options=0时)，waitpid挂起调用进程的执行，直到它的等待集合(wait set)
中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么waitpid
就立即返回。在这两种情况中，waitpid返回导致waitpid返回的已终止子进程的PID。此时，
已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。

#### 1. 判定等待集合的成员
等待集合的成员是由参数pid确定的：
- 如果pid>0，那么等待集合就是一个单独的子进程，它的进程D等于pid。
- 如果pid=-1，那么等待集合就是由父进程所有的子进程组成的。

waitpid西数还支持其他类型的等待集合，包括Unix进程组，

#### 2. 修改默认行为
可以通过将options设置为常量WNOHANG、WUNTRACED和WCONTINUED的各种组合来修改默认行为:
- WNOHANG:如果等待集合中的任何子进程都还没有终止，那么就立即返回(返回值为0)。默认的
行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，
这个选项会有用。
- WUNTRACED:挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的
PID为导致返回的已终止或被停止子进程的PID。默认的行为是只返回已終止的子进程。当你想要检
查已终止和被停止的子进程时，这个选项会有用。
- WCONTINUED:挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个
被停止的进程收到SIGCONT信号重新开始执行。

可以用或运算把这些选项组合起来。例如:
- WNOHANG | WUNTRACED:立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为0;
如果有一个停止或终止，则返回值为该子进程的PID

#### 3. 检查已回收子进程的退出状态
如果statusp参数是非空的，那么waitpid就会在status中放上关于导致返回的子进程的状态信息，
status是statusp指向的值。wait.h头文件定义了解释status参数的几个宏:
- WIFEXITED(status):如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。
- WEXITSTATUS(status):返回一个正常终止的子进程的退出状态。只有在WIFEXITED()返回为真时，
才会定义这个状态。
- WIFSIGNALED(status):如果子进程是因为一个未被捕获的信号终止的，那么就返回真。
- WTERMSIG(status):返回导致子进程终止的信号的编号。只有在WIFSIG-NALED()返回为真时，
才定义这个状态。
- WIFSTOPPED(status):如果引起返回的子进程当前是停止的，那么就返回真。
- WSTOPSIG(status):返回引起子进程停止的信号的编号。只有在WIFSTOPPED()返回为真时，才定义这个状态。
- WIFCONTINUED(status):如果子进程收到SIGCONT信号重新启动，则返回真。

#### 4. 错误条件
如果调用进程没有子进程，那么waitpid返回-1，并且设置errno为ECHILD。如果waitpid两数被一个信号中断，
那么它返回-1，并设置errno为EINTR。

#### 5. wait函数
wait两数是waitpid函数的简单版本:

调用wait(&status)等价于调用waitpid(-1,&status,0)。

#### 6. 使用waitpid的示例

### 4. 让进程休眠
sleep西数将一个进程挂起一段指定的时间。

### 5. 加载并运行程序
execve函数在当前进程的上下文中加载并运行一个新程序。

execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。
只有当出现错误时，例如找不到filename,execve才会返回到调用程序。所以，与fork一次
调用返回两次不同，execve调用一次并从不返回。


**程序与进程**

这是一个适当的地方，停下来，确认一下你理解了程序和进程之间的区别。程序是一堆代码和数据;
程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体
的实例;程序总是运行在某个进程的上下文中。如果你想要理解fork和execve函数，理解这个差异
是很重要的。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。
execve函数在当前进程的上下文中加載并运行一个新的程序。它会覆盖当前进程的地址空间，
但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve西数时已打开
的所有文件描述符。

### 6. 利用fork和execve运行程序

## 5. 信号
Linux信号，它能允许进程和内核中断其他进程。

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。

每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，
对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

![](https://raw.githubusercontent.com/lsill/gitLink/main/document/photo/note/30signtable.jpg)

### 1. 信号术语
传送一个信号到进程是由两个不同步骤组成：
- 发送信号：内核通过更新目的进程上下文中的某个状态，发送(递送)一个信号给目的进程。
发送信号可以有如下两种原因:1)内核检测到一个系统事件，比如除零错误或者子进程终止。
2)一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。
- 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。
进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户
层函数捕获这个信号。

一个发出而没有被接收的信号叫做`待处理信号(pending signal)`。在任何时刻，一种类型
至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送
到这个进程的类型为k的信号都不会排队等待;它们只是被简单地丢弃。一个进程可以有选择性地
阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，
直到进程取消对这种信号的阻塞。

一个待处理信号最多只能被接收一次。内核为每个进程在pending位向量中维护着待处理信号
的集合，而在blocked位向量中维护着被阻塞的信号集合。只要传送了一个类型为k的信号，
内核就会设置pending中的第k位，而只要接收了一个类型为k的信号，内核就会清除pending
中的第k位。

### 2. 发送信号
Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组(process group)这个概念的。

#### 1. 进程组
每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。getpgrp函数返回当前进程的进程组ID.
```
#include <unistd.h>
pid_t getpgrp(void);
```
默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid两数来改变自己或者其
他进程的进程组:
```
#include sunista.h>
int setpgid (pid_t pid, pid_t pgid);
```
setpgid两数将进程pid的进程组改为pgid。如果pid是0，那么就使用当前进程的PID。如果pgid是0，
那么就用pid指定的进程的PID作为进程组ID。例如，如果进程15213是调用进程，那么
setpgid(0,0);
会创建一个新的进程组，其进程组ID是15213，并且把进程15213加人到这个新的进程組中。

#### 2. 用/bin/kil程序发送信号
/bin/ki11程序可以向另外的进程发送任意的信号。比如，命令

linux>/bin/kill -9 15213

发送信号9(SIGKILL)给进程15213。一个为负的PID会导致信号被发送到进程组PID中的每个进程。比如，命令

linux>/bin/kill -9 -15213

发送一个SIGKIIL信号给进程组15213中的每个进程。注意，
在此我们使用完整路径/bin/kill，因为有些Unixshell有自己内置的kill命令。

#### 3. 从键盘发送信号
Unixshell使用作业(job)这个抽象概念来表示为对一条命令行求值而创建的进程。
在任何时刻，至多只有一个前台作业和0个或多个后台作业。比如，键入

linux>ls | sort

会创建一个由两个进程组成的前台作业，这两个进程是通过Unix管道连接起来的:
一个进程运行ls程序，另一个运行sort程序。shell为每个作业创建一个独立的
进程组。进程组ID通常取自作业中父进程中的一个。

在键盘上输人Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程。
默认情况下，结果是终止前台作业。类似地，输人Ctrl十z会发送一个SIGTSTP信号
到前台进程组中的每个进程。默认情况下，结果是停止(挂起)前台作业。

#### 4. 用kill函数发送信号
进程通过调用kill函数发送信号给其他进程(包括它们自己)。
```
#include <sys/types.h>
#include <signal.h>
int kill (pid_t pid, int sig);
// 返回:若成功期为0， 若错误则为一1。
```
如果pid大于零，那么kill函数发送信号号码sig给进程pid。如果pid等于零，那么kill
发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid小于零，
kill发送信号sig给进程组|pid|(pid的绝对值)中的每个进程。

#### 5. 用alarm函数发送信号
进程可以通过调用alarm两数向它自己发送SIGALRM信号。
```
#include <unistd.h>
unsigned i n t alarm(unsigned int secs)
// 返回:前一次 钟剩余的秒数，若以前没有设定闹钟，則为0。
```
alarm函数安排内核在secs秒后发送一个SIGALRM信号给调用进程。如果secs是零，
那么不会调度安排新的用钟(alarm)。在任何情况下，对alarm的调用都将取消任何
待处理的(pending)闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数(如
果这次对alarm的调用没有取消它的话);如果没有任何待处理的闹钟，就返回零。

### 3. 接受信号
当内核把进程p从内核模式切换到用户模式时(例如，从系统调用返回或是完成了一次上下文切换)，
它会检查进程p的未被阻塞的待处理信号的集合(pending&~blocked)。如果这个集合为空(通常
情况下)，那么内核将控制传递到p的逻辑控制流中的下一条指令(Inext)。然而，如果集合是非空
的，那么内核选择集合中的某个信号么(通常是最小的k)，并且强制`p接受`信号k。收到这个信号
会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回p的逻辑控制流中的下一条
指令(Inext)。每个信号类型都有一个预定义的默认行为，是下面中的一种:
- 进程终止
- 进程终止并转储内存
- 进程停止（挂起）知道被SIGCONT信号重启
- 进程忽略该信号

```
#include <signal .h>
typedef void (*sighandler_t) ( i n t ) ;
sighandler_t signal(int signum, sighandler_t handler); 
// 返回:若成功则为指向前次处理程序的指针，若出錯則为SIG_ERR( 不设置erzno).
```
收到SIGKILL的默认行为就是终止接收进程。另外，接收到SIGCHLD的默认行为就是忽略这个信号。
进程可以通过使用signal函数修改和信号相关联的默认行为。唯一的例外是SIGSTOP和SIGKILL,
它们的默认行为是不能修改的。

signal两数可以通过下列三种方法之一来改变和信号signum相关联的行为
- 如果handler是SIG_IGN，那么忽略类型为signum的信号。
- 如果handler是SIG_DFL，那么类型为signum的信号行为恢复为默认行为。
- 否则，handler就是用户定义的函数的地址，这个函数被称为`信号处理程序`，只要进程
接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal
函数从而改变默认行为，这叫做`设置信号处理程序(installing the handler)`。调用
信号处理程序被称为`捕获信号`。执行信号处理程序被称为`处理信号`。

当一个进程捕获了一个类型为k的信号时，会调用为信号k设置的处理程序，一个整数参数被
设置为k。这个参数允许同一个处理函数捕获不同类型的信号。

当处理程序执行它的return语句时，控制(通常)传递回控制流中进程被信号接收中断位置处的指令。
我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一个错误。

### 4. 阻塞和解除阻塞信号
Linux提供阻塞信号的隐式和显式的机制:

`隐式阻塞机制`。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。

`显式阻塞机制`。应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

### 5. 编写信号处理程序
信号处理是Linux系统编程最辣手的一个问题。处理程序有几个属性使得它们很难推理分析:
1)处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰;
2)如何以及何时接收信号的规则常常有违人的直觉;
3)不同的系统有不同的信号处理语义。

#### 1. 安全的信号处理
信号处理程序很麻烦是因为它们和主程序以及其他信号处理程序并发地运行，
如果处理程序和主程序并发地访问同样的全局数据结构，那么结果可能就不可
预知，而且经常是致命的。

一些保守的编写处理程序的原则，使得这些处理程序能安全地并发运行。如果忽视这些原则，
就可能有引人细微的并发错误的风险。如果有这些错误，程序可能在绝大部分时候都能正确
工作。然而当它出错的时候，就会错得不可预测和不可重复，这样是很难调试的。一定要防患
于未然!
- G0.`处理程序要尽可能简单`。避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，
处理程序可能只是简单地设置全局标志并立即返回;所有与接收信号相关的处理都由主程序执行，
它周期性地检查(并重置)这个标志。
- G1.`在处理程序中只调用异步信号安全的函数`。所谓异步信号安全的函数(或简称安全的函数)
能够被信号处理程序安全地调用，原因有二:要么它是`可重入的`(例如只访问局部变量)，要么它不
能被信号处理程序中断。信号处理程序中产生输出唯一安全的方法是使用write函数。
- G2.`保存和恢复errno`。许多Linux异步信号安全的函数都会在出错返回时设置errno。
在处理程序中调用这样的函数可能会干扰主程序中其他依赖于errno的部分。解决方法是在进
入处理程序时把errno保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理
程序要返回时才有此必要。如果处理程序调用_exit终止该进程，那么就不需要这样做了。
- G3.`阻寒所有的信号，保护对共享全局数据结构的访问`。如果处理程序和主程序或其他处理程序
共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞
所有的信号。这条规则的原因是从主程序访问一个数据结构d通常需要一系列的指令，如果指令序列被
访问d的处理程序中断，那么处理程序可能会发现d的状态不一致，得到不可预知的结果。在访问d时暂
时阻塞信号保证了处理程序不会中断该指令序列。
  - G4.`用volatile声明全局变量`。考虑一个处理程序和一个main函数，它们共享一个全局变量g。
处理程序更新g，main周期性地读g。对于一个优化编译器而言，main中g的值看上去从来没有变化过，
因此使用缓存在寄存器中g的副本来满足对g的每次引用是很安全的。如果这样，main函数可能永远都
无法看到处理程序更新过的值。
可以用volatile类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如:volatile int g;
volatile限定符强迫编译器每次在代码中引用g时，都要从内存中读取g的值。一般来说，和其他所有共
享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。
- G5.`用sig_atomic_t声明标志`。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。
主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C提供一种整型数据
类型sig_atomic_t，对它的读和写保证会是原子的(不可中断的)，因为可以用一条指令来实现它们:
volatile sig_atomic_t flag;
因为它们是不可中断的，所以可以安全地读和写sig_atomic_t变量，而不需要暂时阻塞信号。注意，这里对
原子性的保证只适用于单个的读和写，不适用于像flag++或f1ag=f1ag+10这样的更新，它们可能需要多条指令。

这里讲述的规则是保守的，也就是说它们不总是严格必需的。例如，如果你知道处理程序绝对不会修改errno
，那么就不需要保存和恢复errno。或者如果你可以证明printf的实例都不会被处理程序中断，那么在处理
程序中调用printf就是安全的。对共享全局数据结构的访问也是同样。不过，一般来说这种断言很难证明。
所以建议采用保守的方法，遵循这些规则，使得处理程序尽可能简单，调用安全函数，保存和恢复errno，
保护对共享数据结构的访问，并使用volatile和sig_atomic_t。

#### 2. 正确的信号处理
信号的一个与直觉不符的方面是木处理的信号是不排队的。因为pending位向量中
每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。因此，
如果两个类型k的信号发送给一个目的进程，而因为目的进程当前正在执行信号k的
处理程序，所以信号k被阻塞了，那么第二个信号就简单地被丢弃了;它不会排队。
关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。

```c
/* WARNNING: This code is buggy!*/
// SIGCHLD 处理程序
void handler1(int sig)
{
    int olderrno = errno;
    if ((waitpid(-1, NULL, 0)) < 0)
        sio_error("waitpid error");
    Sio_puts("Handler reaped child\n");
    Sleep(1);
    errno = olderrno;
}

int main()
{
    int i, n;
    char buff[MAXBUF];
    if (signal(SIGNHLD, handler1) == SIG_ERR)
        unix_error(signal error);
    /* Parent creates children */
    // 创建3个子进程
    for (i = 0; i < 3;i++) 
    {
        if (FORK() == 0)
        {
            printf("Hello from child %d\n", (int)getpid());
            exit(0);
        }
    }
    /* Parent waits for termainal input and then processes it */
    // 父进程等待来自终端一个输入行
    if ((n = read(STDIN_FILENO, buf, sizeof(buf))) < 0)
        unix_error("read");
     printf("Parent processing input\n");
     while(1);
     exit(0);
}
// signal1:这个程序是有缺陷的，因为它假设信号是排队的
```
当每个子进程终止时，内核通过发送一个SIGCHLD信号通知父进程。父进程捕获这个SIGCHLD信号，
回收一个子进程，做一些其他的清理工作(模型化为sleep语句)，然后返回。

输出：
```
linux> ./signal1
Hello from child 14073 
Hello from child 14074 
Hello from child 14075 
Handler reaped child 
Handler reaped child
CR
Parent processing input
```
从输出中我们注意到，尽管发送了3个SIGCHLD信号给父进程，但是其中只有两个信号被接收了，
因此父进程只是回收了两个子进程。如果挂起父进程，我们看到，实际上子进程14075没有被回收，
它成了一个僵死进程(在ps命令的输出中由字符串“defunct”表明):

问题就在于我们的代码没有解决信号不会排队等待这样的情况。所发生的情况是:父进程接收并捕获
了第一个信号。当处理程序还在处理第一个信号时，第二个信号就传送并添加到了待处理信号集合里。
然而，因为SIGCHLD信号被SIGCHLD处理程序阻塞了，所以第二个信号就不会被接受。此后不久，就
在处理程序还在处理第一个信号时，第三个信号到达了。因为已经有了一个待处理的SIGCHLD，第三个
SIGCHLD信号会被丢弃。一段时间之后，处理程序返回，内核注意到有一个待处理的SIGCHLD信号，
就迫使父进程接收这个信号。父进程捕获这个信号，并第二次执行处理程序。在处理程序完成对第二个
信号的处理之后，已经没有待处理的SIGCHLD信号了，而且也绝不会再有，因为第三个SIGCHLD的所有
信息都已经丟失了。由此得到的重要教训是，`不可以用信号来对其他进程中发生的事件计数`。

为了修正这个问题，必须回想一下，存在一个待处理的信号只是暗示自子程最后一次收到一个信号以来，
至少已经有一个这种类型的信号被发送了。所以我们必须修改SIGCHLD的处理程序，使得每次SIGCHLD
处理程序被调用时，回收尽可能多的僵死子进程。
```
void handler2(int sig)
{
    int olderrno = errno;
    while ((waitpid(-1, NULL, 0)) > 0)
    {
        Sio_puts("Handler reaped child\n");
    }
    if (errno != ECHILD)
        Sio_error("waitpid error");
    
    Sleep(1);
    errno = olderrno;
}
```

#### 3. 可移植的信号处理
Unix信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。例如：
- signal函数的语义各有不同。有些老的Unix系统在信号k被处理程序捕获之后就把对信号k的
反应恢复到默认值。在这些系统上，每次运行之后，处理程序必须调用signal函数，显式地重新设置它自己。
- 系统调用可以被中断。像read write和accept这样的系统调用潜在地会阻塞进程一段较长的时间，
称为`慢速系统调用`。在某些较早版本的Unix系统中，当处理程序捕获到一个信号时，被中断的慢速
系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将errno设置为EINTR。
在这些系统上，程序员必须包括手动重启被中断的系统调用的代码。

要解决这些问题，Posix标准定义了sigaction两数 ，它允许用户在设置信号处理时，明确指定他们想要的
信号处理语义。
```c
#include ssignal.h>
int sigaction(int signum, struct sigaction *act, struct sigaction *oldact);
// 返回:若成功則为0，若出错则为一1
```
sigaction两数运用并不广泛，因为它要求用户设置一个复杂结构的条目。一个更简洁的方式，最初是由
W.RichardStevens提出的[110]，就是定义一个包装函数，称为Signal，它调用sigaction。
signal包装两数设置了一个信号处理程序，其信号处理语义如下:
- 只有这个处理程序当前正在处理的那种类型的信号被阻塞。
- 所有信号实现一样，信号不会排队等待。
- 只要可能，被中断的系统调用会自动重启。•
- 一旦设置了信号处理程序，它就会一直保持，直到signal带着handler参数为SIG_IGN或者SIG_DFL-被调用。


### 6. 同步流以避免讨厌的并发错误
### 7. 显示地等待信号

## 6. 非本地跳转
非本地跳转(nonlocal jump)，它将控制直接从一个函数转移到另一个当前正在执行的函数，
而不需要经过正常的调用返回序列。非本地跳转是通过setjmp和longjmp两数来提供的。
```c
#include sset jmp.h>
int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
// 返回:setjmp返回0，longjmp返回非零
```
setjmp函数在env缓冲区中保存当前调用环境，以供后面的longjmp使用，并返回0。
调用环境包括程序计数器、栈指针和通用目的寄存器。setjmp返回的值不能被赋值给变量:

不过它可以安全地用在switch或条件语句的测试中[62]。

```c
#include <setjmp.h>
void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
// 从不返回
```
longjmp两数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。
然后setjmp返回，并带有非零的返回值retval。

第一眼看过去，setjmp和longimp之间的相互关系令人迷惑。setjmp函数只被调用一次，但返回多次:
一次是当第一次调用setjmp，而调用环境保存在缓冲区env中时，一次是为每个相应的longjmp调用。
另一方面，longjmp函数被调用一次，但从不返回。

非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误
情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返
回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。

非本地跳转的示例。本示例表明了使用非本地跳转来从深层嵌套的西数调用中的错误情况饭复，
而不需要解开整个栈的基本框架
setjmp.c
```c
#include "csapp.h"

jmp_buf buf;

int error1 = 0;
int error2 = 1;

void foo(void), bar(void);

int main()
{
    switch(setjmp(buf))
    {
        case 0:
            foo();
            break;
        case 1:
            printf("Detectd an error1 condition in foo\n")
            break;
        case 2:
            printf("Detectd an error2 condition in foo\n")
            break;
        defaul:
            printf(Unknown error condition in foo\n")
    }
    exit(0);
}


void foo(void)
{
    if (error1)
        longjmp(buf, 1);
    bar();
}

void bar(void)
{
    if (error2)
        longjmp(buf, 2);
}
```
longjmp允许它跳过所有中间调用的特性可能产生意外的后果。例如，如果中间函数调用中分配了某些
数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳过，因而会产生内存泄漏。

非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到
被信号到达中断了的指令的位置。

## 7. 操作进程的工具
Linux系统提供了大量的监控和操作进程的有用工具。

- STRACE:打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的
学生而言，这是一个令人着迷的工具。用-static编译你的程序，能得到一个更干净的、不
带有大量与共享库相关的输出的轨迹。
- PS:列出当前系统中的进程(包括僵死进程)。
- TOP:打印出关于当前进程资源使用的信息。
- PMAP:显示进程的内存映射。

/proc:一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以
读取这些内容。比如，输人“cat/proc/loadavg”，可以看到你的Linux系统上当前的平均负载

## 8. 小结
异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。

在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，
该处理程序进行一些处理，然后返回控制给被中断的控制流。

有四种不同类型的异常:中断、故障、终止和陷阱。当一个外部I/O设备(例如定时器芯片或者磁
盘控制器)设置了处理器芯片上的中断管脚时，(对于任意指令)中断会异步地发生。控制返回到
故障指令后面的那条指令。一条指令的执行可能导致放障和终止同步发生。故障处理程序会重新
启动故障指令，而终止处理程序从不將控制返回给被中断的流。最后，陷阱就像是用来实现向应
用提供到操作系统代码的受控的入口点的系统调用的函数调用。

在操作系统层，内核用ECF提供进程的基本概念。进程提供给应用两个重要的抽象:1)逻辑控制流，
它提供给每个程序一个假象，好像它是在独占地使用处理器，2)私有地址空间，它提供给每个程序
一个假象，好像它是在独占地使用主存。

在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，
运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同。
然而，在与Posix兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。

最后，在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数
分支到另一个函数。






























