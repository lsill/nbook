---
title: "程序编码"
date: 2023-09-07T16:00:48+08:00
draft: true
---

### 1. 机器级代码
- 程序计数器(PC) （在x86中用%rip表示），给出将要执行下一条指定在内存中的地址
- 整数寄存器 文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于c语言的指针）或整数数据。
  有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部的变量以及函数的返回值。
- 条件码寄存器 保存着最近执行的算术或者逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句。
- 一组向量寄存器可以存放一个或多个整数或者浮点数值。

程序内存包含：
1. 程序的可执行机器代码
2. 操作系统需要的一些信息
3. 用来管理过程调用和函数的运行时栈
4. 用户分配的内存块（比如malloc）


x86-64 的虚拟地址是有64位的字表示的，在目前的实现中，这些地址的高16位必须设置成0，所以一个地址实际上能够指定的是2^48或64TB范围内的一个字节。比较典型的是程序只会访问几兆或几千兆字节的数据

操作系统负责管理虚拟地址空间，将虚拟地址空间翻译成实际处理器内存中的物理地址。

```c
long mult2(long, long);

void mulstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```
linux>gcc -Og -S mstore.c
```
mulstore:
.LFB0:
        .cfi_startproc
        pushq   %rbx  // 寄存器将%rbx的内容压入程序栈中
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
```
如果使用-c命令，gcc会编译并汇编该代码
linux>gcc -Og -c mstore.c
会产生目标代码文件mstore.o，它是二进制格式，所以无法直接查看

要查看机器代码文件的内容，有一类称为反汇编器的程序非常有用。这些程序根据机器代码产生的一种类似汇编代码的格式。在linux系统中，
带-d的命令标志objdump可以充当这个角色:
linux> objdump -d mstore.o
解锁如下
```
[root@demo2 procodeing]# objdump -d mstore.o

mstore.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <mulstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	callq  9 <mulstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	retq
```
在左边看到前面给出的字节顺序排列的14个进制字节值，它们分成了若干组，每组1~5个字节。每组都是一条指令，右边是等价的汇编语言。
关于机器代码和它的反汇编表示的特性值注意：
- x86-64的指令长度从1到15个字节不等。常用的指令以及操作较少的指令所需的字节少，而那些不太常用或者操作数较多的指令所需的字节数较多。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一的解码成机器指令。例如，只有pushq %rbx是以字节值53开头的。
- 反汇编器只是给予机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命令规则与gcc生成的汇编代码使用的有些细微差别。在实例中，它省略了很多指令结果的'q'。这些后缀是大小指示符，在大多数情况中可以省略。
  相反，反汇编给call和ret指令添加了'q'后缀，同样，省略这些后缀也没有问题.

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标文件中必须含有一个main函数
```c
#include<stdio.h>

void multstore(long,long,long*);

int main() {
        long d;
        multstore(2,3,&d);
        printf("2 * 3 --> %ld\n",d);
        return 0;
}

long mult2(long a,long b) {
        long s = a * b;
        return s;
}
```
linux> gcc -Og -0 prog main.c mstore.c
反会半期会抽取各种代码序列，包含下面这段：
```
00000000004005d4 <multstore>:
  4005d4:	53                   	push   %rbx
  4005d5:	48 89 d3             	mov    %rdx,%rbx
  4005d8:	e8 ef ff ff ff       	callq  4005cc <mult2>
  4005dd:	48 89 03             	mov    %rax,(%rbx)
  4005e0:	5b                   	pop    %rbx
  4005e1:	c3                   	retq
  4005e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4005e9:	00 00 00
  4005ec:	0f 1f 40 00          	nopl   0x0(%rax)
```
这段反汇编产生的代码几乎完全一样，
- 其中一个主要的区别是左边列出的地址不同————丽娜姐器将这段代码的地址移到了一段不同的地址范围中，
- 第二个不同在于链接器填上了callq指令调用函数mult2需要的地址。
  **链接器** 的任务之一就是为了函数调用找到匹配的函数的可执行代码的位置
- 最后一个区别是多了两行代码，这两条指令对程序没有影响，应为它们出现在返回执行后面。插入这些指令
  是为了是函数代码变为16字节，使得就操作系统性能而言，能更好的防止下一代码块

### 2. 格式注解
mstore.s 完整内容：
```
        .file   "mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
.LFB0:
        .cfi_startproc
        pushq   %rbx 
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        movq    %rdx,
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE0:
        .size   multstore, .-multstore
        .ident  "GCC: (GNU) 8.5.0 20210514 (Red Hat 8.5.0-4)"
        .section        .note.GNU-stack,"",@progbits
```
所有'.'开头的行都是指导汇编器和链接器工作的伪指令。（通常可以忽略）
```
void multstore(long x,long y, long *dest)
x in %rdi, y in %rsi, dest in %rdx

multstore:
        pushq   %rbx  保存*dest到%rbx中（栈压入）
        movq    %rdx, 复制*dest到rbx中
        call    mult2 调用函数mult2
        movq    %rax, (%rbx)  存储结果到*dest
        popq    %rbx  恢复rbx (栈弹出)
        ret 返回
```

### 3. 数据格式
| c声明    | inter数据类型 | 汇编代码后缀 | 大小（字节） |
|--------|-----------|--------|--------|
| char   | 字节        | b      | 1      |
| short  | 字         | w      | 2      |
| int    | 双字        | l      | 4      |
| long   | 四字        | q      | 8      |
| char*  | 四字        | q      | 8      |
| float  | 单精度       | s      | 4      |
| double | 双精度       | l      | 8      |


### 4. 访问信息
一个x86-64的cpu包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。
16位：%ax-%bp
32位:%eax-%ebp
64位:%rax-%rbp 还增加了8个新的寄存器%r8-%r15

| 63   | 31    | 15    | 7     | 0      |
|------|-------|-------|-------|--------|
| %rax | %eax  | %ax   | %al   | 返回值    |
| %rbx | %ebx  | %bx   | %bl   | 被调用者保存 |
| %rcx | %ecx  | %cx   | %cl   | 第4个参数  |
| %rdx | %edx  | %dx   | %dl   | 第三个参数  |
| %rsi | %esi  | %si   | %sil  | 第二个参数  |
| %rdi | %edi  | %di   | %dil  | 第一个参数  |
| %rbp | %ebp  | %bp   | &bpl  | 被调用者保存 |
| %rsp | %esp  | %sp   | %spl  | 栈指针    |
| %r8  | %r8d  | %r8w  | %r8b  | 第五个参数  |
| %r9  | %r9d  | %r9w  | %r9b  | 第六个参数  |
| %r10 | %r10d | %r10w | %r10b | 调用者保存  |
| %r11 | %r11d | %r11w | %r11b | 调用者保存  |
| %r12 | %r12d | %r12w | %r12b | 被调用者保存 |
| %r13 | %r13d | %r13w | %r13b | 被调用者保存 |
| %r14 | %r14d | %r14w | %r14b |     被调用者保存   |
| %r15 | %r15d | %r15w | %r15b |   被调用者保存     |
整数寄存器，所有16个寄存器的低位部分都可以作为字节、字、双字和四字数字来访问。

#### 1.操作数指示符
大多数指令有一个活多个操作数，指示出执行一个操作中要使用的元数据值，以及放置结果的目标位置。
源数据值可以以常数形式给出、或是从寄存器或内存中读出。
结果可以存放在寄存器或内存中。

有不同的`寻址模式`，允许不同形式的内存引用，Imm(rb,ri,s)表示的是最常用的形式，这样的引用有四个组成部分：
一个立即数便宜Imm,一个基址寄存器rb，一个变址寄存器ri和一个比例因子s，这里s必须是1，2，4或者8.
基址和变址寄存器都必须是64位寄存器。
有效地址：`Imm+R[rb]+R[ri]*s`。引用数组元素时会用到这种通用形式。其他形式都是这种通用形式的特殊情况，
只是省略了某些部分。

| 类型  | 格式           | 操作数值                 | 名称         |
|-----|--------------|----------------------|------------|
| 立即数 | $Imm         | Imm                  | 立即数寻址      |
| 寄存器 | ra           | R[ra]                | 寄存器寻址      |
| 存储器 | Imm          | M[Imm]               | 绝对寻址       |
| 存储器 | (ra)         | M[R[ra]]             | 间接寻址       |
| 存储器 | Imm(rb)      | M[Imm+R[rb]]         | （基址+偏移量）寻址 |
| 存储器 | (rb,ri)      | M[R[rb]+R[ri]]       | 变址寻址       |
| 存储器 | Imm(rb, ri)  | M[Imm + R[rb]+R[ri]] | 变址寻址       |
| 存储器 | (,ri,s)      | M[R[ri]*s]           | 比例变址寻址     |
| 存储器 | Imm(,ri,s)   | M[Imm+R[ri]*s]       | 比例变址寻址     |
| 存储器 | (rb,ri,s)    | M[R[rb]+R[ri]*s]     | 比例变址寻址     |
| 存储器 | Imm(rb,ri,s) | M[Imm+R[rb]+R[ri]*s] | 比例变址寻址     |

#### 2.数据传送指令mov
数据传输指令是使用最频繁的指令。

| 指令          | 效果   | 描述     |
|-------------|------|--------|
| MOV  S,D    | S->D | 传送     |
| movb        |      | 传送字节   |
| movw        |      | 传送字    |
| movl        |      | 传送双字   |
| movq        |      | 传送四字   |
| movabsq I,R | I->R | 传送绝对四字 |

- 源操作数指定的值是一个立即数，存储在寄存器或者内存中
- 目的操作室指定的一个位置，要么是一个寄存器，要么是个内存地址
- x86-64传送指令的两个操作数不能都指向内存位置
  将一个值从内存位置复制到另一个内存位置需要两条指令
  1. 将源值加载到寄存器中
  2. 将寄存器值写入目的内存值中
- 指令的寄存器操作数可以使16个寄存器有标号部分中的任意一个
- 寄存器部分的大小必须与指令最后一个字符(b,w,l,q)指定的大小匹配
- 大多数情况中mov指令只会更新目的操作数指定的那些寄存器字节或内存位置，唯一
  例外是movl指令以寄存器作为目的时，它会把该寄存器的高4字节设置成0。造成这个
  例外的原因是x86-64的惯例————任何寄存器生成32位值的指令都会把该寄存器的高位
  不分置成0
- 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号
  扩展到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作室，
  并且只能以寄存器作为目的。

将较小的源值复制到较大的目的时使用两类数据移动指定。所有这些指令都把数据从源（在寄存器或内存中）
复制到目的寄存器。
- movz类中的指令把目的中剩余的字节填充位0
- movs类中的指令通过符号来填充，把源操作的最高位进行复制。
  例如：movsbq $AA,%rax  %rax = FFFFFFFFFFFFFAA (A = 1010 符号位是1)

每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，第二个指明目的的大小。

| 指令        | 效果        | 描述             |
|-----------|-----------|----------------|
| MOVZ  S,R | 零扩展(S)->R | 以零扩展进行传送       |
| movzbw    |           | 将做了零扩展的字节传送到字  |
| movzbl    |           | 将做了零扩展的字节传送到双字 |
| movzwl    |           | 将做了零扩展的字传送到双字  |
| movzbq    |           | 将做了零扩展的字节传送到四字 |
| movzwq    |           | 将做了零扩展的字传送到四字  |

零扩展数据传送指令：这些指令以寄存器或内存地址作为源，以寄存器为目的。

| 指令        | 效果               | 描述              |
|-----------|------------------|-----------------|
| MOVS  S,R | 符号扩展扩展(S)->R     | 以零扩展进行传送        |
| movsbw    |                  | 将做了符号扩展的字节传送到字  |
| movsbl    |                  | 将做了符号扩展的字节传送到双字 |
| movswl    |                  | 将做了符号扩展的字传送到双字  |
| movsbq    |                  | 将做了符号扩展的字节传送到四字 |
| movswq    |                  | 将做了符号扩展的字传送到四字  |
| movslq    |                  | 将做了符号扩展的双字传送到四字 |
| cltp      | 符号扩展（%rax）->%rax | 把%eax符号扩展到%rax  |

符号扩展数据传送令：movs指令以寄存器或内存地址作为源，以寄存器作为目的。cltp指令制作用于
寄存器%eax和%rax
cltp效果和movslq %eax，%rax 完全一致

#### 3.数据传送指令实例
c代码
```c
long exchange(long *xp, longy)
{
    long x = *xp;
    *xp = y;
    return x;
}
```

汇编代码
```
long exchange(long *xp, long y)
xp in %rdi, y in %rsi
exchange:
  movq (%rdi), %rax  // 内存中读出x，把它放在寄存器%rax中（%rax是返回值）
  movq %rsi, (%rdi)  // 将y写入到寄存器%rdi中xp指向的内存位置
  ret
```
间接引用指针就是将该指针放在一个寄存器中，然后内存引用使用这个寄存器。

**练习题：**
src_t *sp;
dest_t *dp;

设sp和dp的值分别存储在%rdi和%rsi，汇编实现*dp = (dest_t) *sp;
需要两条指令
1. 从内存中读数，做适当转换，并设置到寄存器%rax的适当部分（%rax,%eax,%ax,%al）
2. 把%rax的适当部分写入到内存中。

| src_t         | dest_t        | 指令                                  | 详解                 |
|---------------|---------------|-------------------------------------|--------------------|
| long          | long          | movq (%rdi),%rax;movq %rax,(%rsi)   | 不用做扩展，正常4字移动       |
| char          | int           | movsbl (%rdi),%eax;movl %eax,(%rsi) | char有符号，需要符号扩展到双字  |
| char          | unsigned      | movsbl (%rdi),%eax;movl %eax,(%rsi) | char有符号，需要符号扩展到双字  |
| unsigned char | long          | movzbl (%rdi),%eax;movq %rax,(%rsi) | 读一个字节，无符号char扩展到4字 |
| int           | char          | movl (%rdi),%eax;movb %al,(%rsi)    | 不需要扩展，双字缩减到字节      |
| unsigned      | unsigned char | movl (%rdi),%eax;movb %al,(%rsi)    | 不需要扩展，双字缩减到字节      |
| char          | short         | movsbw (%rdi),%ax;movw %ax,(%rsi)   | 符号char扩展到字         |

### 5.压入和弹出栈数据
**栈指针(%rsp)保存着栈顶元素地址**
压入和弹出都是对栈顶的地址进行操作，栈顶元素的地址是栈中所有元素地址中最低的。

| 指令      | 效果                               | 描述     |
|---------|----------------------------------|--------|
| pushq S | R[%rsp]-8->R[%rsp];S->M[R[%rsp]] | 将四字压入栈 |
| popq D  | M[R[%rsp]]->D;R[%rsp]+8->R[%rsp] | 将四字弹出栈 |

pushq %rbp 指令等价于
subq $8 %rsp
movq %rbp,(%rsp)
这两个区别是pushq指令编码为1个字节，而上面2个指令一共需要8个字节

popq %rax等价于
movq (%rsp),%rax
addq $8,%rsp

### 6.算术和逻辑操作
指令类有各种大小不同操作数的变种（只有leaq没有其他大小的变种）。
例：addb,addw,addl,addq分别是字节加法，字加法，双字加法，四字加法

| 分组     | 指令       | 效果        | 描述         |
|--------|----------|-----------|------------|
| 加载有效地址 | leaq S,D | &S->D     | 加载有效地址     |
| 一元操作   | INC D    | D+1->D    | 加1         |
|        | DEC D    | D-1->D    | 减1         |
|        | NEG D    | -D->D     | 取反         |
|        | NOT D    | ~D->D     | 取补         |
| 二元操作   | ADD S,D  | D+S->D    | 加          |
|        | SUB S,D  | D-S->D    | 减          |
|        | IMUL S,D | D*S->D    | 乘          |
|        | XOR S,D  | D^S->D    | 异或         |
|        | OR S,D   | D或S->D    | 或          |
|        | AND S,D  | D&S->D    | 与          |
| 移位     | SAL k,D  | D<<K->D   | 左移         |
|        | SHL k,D  | D<<k->D   | 左移（等同于SAL） |
|        | SAR k,D  | D>>q k->D | 算术右移       |
|        | SHR k,D  | D>>l k    | 逻辑右移       |

leaq:通常用来执行简单的算数操作

#### 1. 加载有效地址
leaq实际上是movq指令的变形，指令形式是从内存读数据到寄存器，但实际上它根本没有引用内存。
它的第一个操作数看上去是一个内存引用，但该指令并不是从指定位置读入数据，而是将有效地址写
入到目的擦作数。

编译器经常发现leaq的一些灵活的用法，根本与有效地址计算无关。目的操作数必须是一个寄存器。
```c
long scale(long x,long y,long z) {
    long t = x + 4 * y + 12 * z;
    return t;
}
```

汇编代码:
```
long scale(long x,long y,long z)
x in %rdi, y in %rsi, z in %rdx
scale:
  leaq (%rdi, %rsi, 4), %rax  // x + 4 * y
  leaq (%rdx, %rdx, 2), %rdx  // z + 2 * x = 3*z
  leaq (%rax, %rdx, 4), %rax  // (x + 4 * y) + 4 * (3 * z) = x + 4 * y + 12 * z
```
leaq能执行加法和有限形式的乘法

#### 2. 一元和二元操作
一元操作：只有一个操作数，既是源也是目的，这个操作数可以使一个寄存器也可以是一个内存位置。
例如：incq (%rsp)会使栈顶的8个字节元素加1 
二元操作：第二个操作数既是源又是目的。
例：subq %rax, %rdx 第一个操作数可以使立即数、寄存器或是内存位置，第二个操作数是寄存器或内存位置。
注意：第二个操作数是内存地址时，处理器必须从内存读出值，执行操作，在写会内存。

#### 3. 移位操作
第一位操作数是移位量，第二个操作给出的是要移位的数。
可以进行算术和逻辑右移。
移位量可以是一个立即数，或者放在单字节寄存器%cl中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数）。
1个字节的移位量使得移位量编码范围达到2^8-1= 255，移位操作对w位长的数值进行操作，移位量是有%c寄存器的低m位决定的，
2^m = w，高位会被忽略。
当寄存器%cl的值是0xFF,salb会移动7位，salw会移动15位，sall会移动31位，salq会移动63位。

左移有两个名字：SAL和SHL效果是一样的，都是将右边填0.
右移指令不同，SAR执行算术移位（填上符号位），而SHR执行逻辑移位（填上0）。
移位操作的目的操作数可以是一个寄存器也可以是一个内存位置。

#### 4. 讨论
只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为有符号整数运算的一种比较好的方法之一。

```c
long arith(long x, long y, long z)
{
    long t1 = x ^ y;
    long t2 = z * 48;
    long t3 = t1 & 0x0f0f0f0f;
    long t4 = t2 - t3;
    return t4;
}
```

汇编代码:
```
x in %rdi, y in %rsi, z in %rdx
arith:
  xorq %rsi, %rid             // t1 = x ^ y
  leaq (%rdx, %rdx, 2), %rax  // 3 * z
  salq $4, %rax               // t2 = 16 * （3 * z） = 48 * z
  andl &252645135, %edi       // t3 = t1 & 0x0f0f0f0f
  subq %rdi, %rax             // return t2 - t2
  ret
```

#### 5. xorq %rdx, %rdx效果
1. 这个指令用来将寄存器%rdx设置为0，运用了对任意x,x^x=0这一属性。它对于c语句x=0
2. 将寄存器%rdx设置为0的更直接方式是指令moveq $0,%rdx
3. 使用xorq的版本只需要3个字节，而使用movq的版本需要7个字节。其他将%rdx设置为0的方法都依赖于这样一个属性，
即任何更新低于4字节的指令都会把高位字节设置为0.因此可以使用xorl %edx, %edx(2字节)或movl $0,%edx(5字节)