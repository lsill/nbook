---
title: "0-1背包"
date: 2021-12-09T15:19:15+08:00
draft: true
---

   **背包问题有点难搞，当时搞会了不久就忘记了，记一个自己理解的笔记**

 假设dp数组为dp[i] [j],物品重量为weights[i],物品价值为values[i]则状态转移方式：

```go
 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
```

推导：

​	假设物品a,b,c,d重量和价值如下表，背包负重(bagWeight)为4，求背包能装的物品最大价值是多少（每个物品只能装一次）(a,b,c,d对应的weight和value的索引是0,1,2,3)

|        | 重量（weights） | 价值(values) |
| :----: | :-------------: | :----------: |
| a（0） |        1        |      10      |
| b（1） |        2        |      20      |
| c（2） |        3        |      25      |
| d（3） |        5        |     999      |

​	动态规划的核心是将一个复杂问题拆解成容易计算的子问题，在由子问题推导出解，也就是上面说的状态转移方程，所以先把问题拆解开：

1. 先将问题转化物品为a,b,c,d，负重（bagWeight）为0的背包最多能装多大价值？

2. 接着转化物品为a,b,c,d，负重（bagWeight）为1的背包最多能装多大价值？

   由上表可知，负重为1的背包能且只能装下a，最大价值也就是10

3. 然后再接着将问题变成只有物品a（也只有1件）,负重（bagWeight）为4的背包最多能装多大的价值？

   由于只有一件物品，所以就算背包再大，最大价值始终为a的价值10，结合子问题1和子问题2，我们可以得到价值只和物品+背包重量有关，也就是：

   |        i\j         | 0    | 1     | 2     | 3     | 4     |
   | :----------------: | :--- | :---- | ----- | ----- | ----- |
   |   0（只有a物品）   | 0    | 10    | 10    | 10    | 10    |
   |  1（只有a,b物品）  | 0    | 10(0) | 20    | 30    | 30    |
   | 2（只有a,b,c物品） | 0    | 10(1) | 20(1) | 30(1) | 35    |
   |     3（都有）      | 0    | 10(2) | 20(2) | 30(2) | 35(2) |

   这里我们可以推导出部分公式 **dp[i] [j] = dp[i-1] [j] (i > 0)**

   4.我们再次将问题变成物品为a,b负重（bagWeight）为2的背包最多能装多大价值？

   ​	由子问题3我们可以推导dp[1] [2] = dp[0] [2] == 10,这明显不对啊，b的重量为2，等于背包负重，所以应该是20，也就是value[1], 那么公式再变更下  dp[i] [j] =max( dp[i-1] [j] , value[i])(i > 0,weight[i] <= bagWeight) 

   5.再次将问题扩充到为a,b负重（bagWeight）为3的背包最多能装多大价值？

   ​	在套公式max(dp[1] [3], value[1]) == 20,但3负重下能容纳a和b物品，所以还需要扩展公式，当已经装了2物品的时候还可以装的重量是3-2 也就是 3-weight[1], value[1] + dp[i-1] [3-weight[1]]就是dp[1] [3]的最大价值，也就得到了公式 

   ```go
   dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
   ```

   

例题：

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

​	这道题在知道状态转移方程的情况下最大的难点是如何转变成背包问题，两个子集相等也就是 找到等于所有元素和/2的状态。

可以直接开看题解，很清晰。

