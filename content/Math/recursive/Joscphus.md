---
title: "Joscphus"
date: 2023-08-07T11:00:15+08:00
draft: false
---
## Joscphus问题（约瑟夫环）
[约瑟夫环](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)
这里看图更容易理解问题本质
### 了解递归

### 1. 问题
人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。
问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

### 2.思考
1. 假设有10（1，2，3，4，5，6，7，8，9，10）个人等待被处决
- 第一次遍历2，4，6，8，10 剩余1,3,5,7,9
- 第二次跳过1从3开始，剩余1，5，9
- 第三次从1开始，剩余5

2. 假设有2*n个人的话
- 第一次遍历删除所有偶数，剩余奇数1，3，5...2n-3,2n-1
- 第二次跳过1从3开始，3其实可以表示为2*2-1,是第一次的编号*2-1
- 那么可以假设J(2n) = 2J(n) - 1 (n>=1)

3. 假设有2*n+1个人的话
- 第一次遍历还是删除偶数，剩余数3,5,...2n-1,2n+1(1遍历2n后紧接着被删掉)
- 第二次从跳过3从5开始，5可以表示为2*2+1
- 那么可以假设J(2n+1) = 2J(n) + 1(n>=1)

可以得出递归公式
J(1) = 1
J(2n) = 2J(n) -1 (n>=1)
J(2n+1) = 2J(n) + 1 (n>=1)

假设公式成立，可以得出表

| n    |   1   |  2,3 | 4,5,6,7 |  ... |
| ---- | :---: | ---: | ------: | ---: |
| J(n) |   1   |  1,3 | 1,3,5,7 |  ... |

表中可以用2的幂来分组，2^0是第一组（1），2^1是（2，3）...
假设幂为m，l为幂分组中的值索引, 则n可以表示成**n = 2^m+l**,
由上述归纳可以得出一个公式J(2^m + l) = 2l + 1（这个公式不知道怎么推导出来的，看起来像是看规律）
因为2^m<=n<2^(m+1)，所以l的范围0<=l<2^(m+1)-2^m=2^m


### 4. 证明J(2^m + l) = 2l + 1
- 假设m=0，根据0<=l<2^m,l一定是0，f(1) = 1成立
- n为偶数的话，f(2^m + l) = 2f(2^(m-1) + l /2) - 1 = 2(2l/2 + 1) -1 =2l+1
- 奇数可以从表得出 因为f(2n+1) - f(2n) = 2,归纳法也可以得出f(2^m + l)=2l+1
**这里的没有推导过程，我看的更像是从归纳法总结得出的结论公式**


### 5. 二进制巧合？
** 因为解和2的幂有关系，所以可以往二进制解题方向靠拢**
归纳得到的公式为n=2^m + l = 2l + 1
n = b(b(m)b(m-1)...b(1)b(0)); (这里是二进制表示数字)
n = b(m)*2^m + b(m-1)*2^(m-1)+...b(1)2 + b(0)1
每个b(i)是0或者1表示二进制的符号，第一位b(m)是1。
因为n=2^m + l
- n = (1b(m-1)b(m-2)...b(1)b(0))
- l = (0b(m-1)b(m-2)...b(1)b(0)) (因为l的取值范围在0和2^m之间)
- 2l = (b(m-1)b(m-2...b(1)b(0)0)) （因为*2所以右移一位）
- 2l + 1 = (b(m-1)b(m-2...b(1)b(0)1)) （最低位+1）
- J(n) = (b(m-1)b(m-2)...b(1)b(0)b(m)) （上面说了b^m是1）

上面的推导得到一个很神奇的公式

J((b(m)b(m-1)...b(1)b(0))) = (b(m-1)...b(1)b(0)b(m))
看起来像是把二进制最高位放到最低位就是解，用归纳法试试
n = 100, J((1100100)) = (1001001) 二进制转化成10进制是73，很神奇。

但事情并不是这么简单的，n=13时候J((1101)) = (1011),然后继续求解J((1011))=(111)
0变成第一位的时候，消失了。重复应用J，最终会到达一个“指定点”，那里J(n) = n，将产生一个
全为1的二进制。

最早猜测J(n) = n / 2，这个虽然不成立，但假设它就是成立的，那么：
- J(n) = n / 2
- 2l + 1 = (2^m + l) / 2
- l = 1/3(2^m - 2)

若满足l = 1/3(2^m - 2)是个整数，则n = 2^m + l将是一个解，因为l小于2^m，当m是奇数时候2^m-2是3
的倍数J(n) = n / 2成立

| m   |   l   | n=2^m+l | J(n)=2l+1=n/2 | n(二进制) |
| --- | :---: | ------: | ------------: | --------: |
| 1   |   0   |       2 |             1 |        10 |
| 2   |   2   |      10 |             5 |      1010 |
| 5   |  10   |      42 |            21 |    101010 |
| 7   |  42   |     170 |            85 |  10101010 |


### 6. 找出一般递归式
引入常数α，β，γ，尝试找出一般递归式：
f(1) = α;
f(2n) = 2f(n) + β; (n >= 1)
f(2n+1) = 2f(n) + γ; (n >= 1)
原先的递归式： f(2n) = 2f(n) - 1,f(2n) = 2f(n) + 1(α = 1, β = -1, γ = 1):
构造一般表：

|     |         |
| --- | :------ |
| 1   | α       |
| 2   | 2α+β    |
| 3   | 2α+γ    |
| 4   | 4α+3β   |
| 5   | 4α+2β+γ |
| 6   | 4α+β+2γ |
| 7   | 4α+3γ   |
| 8   | 8α+7γ   |

上述表归纳看起来α的系数是n的最大的2的幂，在2的幂之间，β的系数下降1，向下到0，而γ的系数
从0向上上升到l。
设表达式：f(n) = A(n)α + B(b)γ + C(n)γ
看来：
A(n) = 2^m,
B(n) = 2^m -1 - l,
c(n) = l,

#### (1).选取特殊值a = 0,b=c=0（a = α,b = β,c=γ）
A(1) = 1;
A(2n) = 2f(n);(n >= 1)
A(2n+1) = 2f(n);(n >= 1)
归纳得出A(2^m + 1) = 2^m;

#### (2).假设f(n)是个常函数，f(n)=1
1 = a;
1 = 2*1 + b;
1 = 2*1 + c;
当(a,b,c) = (1,-1,-1)满足上看表达式，这里将产生新的等式：
A(n) - B(n) - C(n) = f(n) = 1.

#### (3).假设f(n) = n
1 = a;
2n = 2 * n + b;
2n + 1 = 2 * n + c;
当(a,b,c) = (1,0,-1)满足上面的表达式，产生新的等式：
A(n)+C(n)=n.

#### 由特殊值得到结论
由(1)(2)(3)的假设可以得到A(n),B(n),C(n)需要满足方程：
- A(n) = 2^m;
- A(n) - B(n) - C(n) = 1;
- A(n) + C(n) = n;

由此可以得到：
- C(n) = n - A(n) = 2^m + l - 2^m = l;
- B(n) = A(n) - 1 - C(n) = 2^m - 1 -l;

特殊值求通用解牛逼奥


### 7. 广义递归
![](https://github.com/lsill/nbook/blob/main/static/images/math/recursive/j0.jpg)
![](https://github.com/lsill/nbook/blob/main/static/images/math/recursive/j1.jpg)
![](https://github.com/lsill/nbook/blob/main/static/images/math/recursive/j2.jpg)

### 8. gpt回答可能的应用
- 缓存淘汰策略：
在缓存系统中，当缓存空间已满时，可以使用约瑟夫环来确定哪些缓存条目应该被淘汰。根据约定的淘汰规则，每次从缓存中淘汰一定数量的条目，直到只剩下最后一个条目。

- 进程调度：
在操作系统中，可以使用约瑟夫环来模拟进程调度算法。每个进程可以表示为圆圈中的一个人，按照一定规则进行淘汰，最终确定下一个要执行的进程。

- 循环列表操作：
约瑟夫环的问题可以看作是在循环列表中按照一定规则进行操作的问题。因此，在需要对循环列表进行操作的情况下，可以使用约瑟夫环的概念来解决。

- 游戏和数学问题：
约瑟夫环问题本身具有一定的数学背景，它与模运算和数学序列有关。因此，在设计游戏或解决某些数学问题时，可以应用约瑟夫环的思想。


这些只是一些可能的应用场景，实际上，约瑟夫环问题的解决方法可以在许多需要对一组对象按照一定规则进行循环操作的情况下发挥作用。

### 9. Joscphus有一个朋友，由于他紧接着最后位置而被救。每当一个第2人被处死时，倒数第二个幸存者编号是什么？
- I(n)和J(n)有着相同的递推关系 I(2n + j) = 2I(n) + ρ(j)
- I(1)不存在，由归纳可知I(2) = 2,I(3) = 1
- [](https://github.com/lsill/nbook/blob/main/static/images/math/recursive/j3.jpg)

